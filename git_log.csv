commit c1906f5669e29910fdf1355548ec147f5ad328a5
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Mon Oct 9 18:26:00 2023 +0100

    updated table of content and remove highlighted text

diff --git a/Group C - Client Server Network Report.docx b/Group C - Client Server Network Report.docx
index f56d5b8..0ef9728 100644
--- a/Group C - Client Server Network Report.docx	
+++ b/Group C - Client Server Network Report.docx	
@@ -87,7 +87,7 @@ Chapter 3. Solution Design	5
 3.1	Solution Design (Client)	5
 3.2	Solution Design (Server)	7
 3.3	Design Decisions	9
-Chapter 4. Unit Testing	9
+Chapter 4. Unit Testing	10
 4.1	Server Unit Testing	10
 4.2	Client Unit Testing	11
 Chapter 5. Conclusion	12
@@ -99,9 +99,9 @@ Introduction
 
 The objective of this project is creating a Client Server Network which once established can facilitate the transmission of encrypted and serialised files. Also, the server must have the seamless mechanism for decrypting and processing these files on the server side.    
 This report and the related code created by Group C will demonstrate the following:
-  1. Capable of Secure Communication between client and server.
-  2. Using Pickle  -  Serialising the data/encryption before transmission from client. 
-  3. Decrypting the data and demonstrating the information in required format by printing it. 
+ Capable of Secure Communication between client and server.
+ Using Pickle  -  Serialising the data/encryption before transmission from client. 
+ Decrypting the data and demonstrating the information in required format by printing it. 
 
 Team has a public repository on GitHub which was used throughout the project for collaboration and version control. Team's public repository can be found using this link  -  
 https://github.com/callmehawa/Client_Server_Network_GroupC. [HYPERLINK: https://github.com/callmehawa/Client_Server_Network_GroupC.git]git
@@ -149,42 +149,42 @@ Python script serverfinal.py is written to receive encrypted data, decrypt it us
 
                                         
 The script operates as follows:
-  * A client socket is established by utilising the create_client_socket() function.
+ A client socket is established by utilising the create_client_socket() function.
    
    
-  * Connects to the server using the connect_to_server() function.
+ Connects to the server using the connect_to_server() function.
    
    
-  * New encryption key is generated and written to a file using the write_key() function.
+ New encryption key is generated and written to a file using the write_key() function.
    
    
    
-  * Encryption key is loaded from the file using the load_key() function
+ Encryption key is loaded from the file using the load_key() function
    
 
-  * The pickle module converts a dictionary into binary format for easy storage and transfer.
+ The pickle module converts a dictionary into binary format for easy storage and transfer.
    
    
-  * The data is serialised and then encrypted using the encrypt() function.
+ The data is serialised and then encrypted using the encrypt() function.
    
    
-  * The data is encrypted and sent to the server using the send_encrypted_data() function
+ The data is encrypted and sent to the server using the send_encrypted_data() function
    
 
-  * The function receive_response() is utilised to obtain a response from the server.
-  * After receiving a response, the system decodes it and displays it on the console as a response from the server.
-  * Before exiting, the script ensures that the client socket is closed.
+ The function receive_response() is utilised to obtain a response from the server.
+ After receiving a response, the system decodes it and displays it on the console as a response from the server.
+ Before exiting, the script ensures that the client socket is closed.
 
 Error handling within the script:
 
-  * If the script cannot create the client socket, it will display an error message and terminate.
-  * If the client socket fails to connect to the server, an error message is printed, and the socket is closed.
-  * If the script fails to generate or write the encryption key to the file, an error message is printed, and the script exits.
-  * If the encryption key cannot be loaded from the file, an error message is printed, and the script exits.
-  * If the serialised data cannot be encrypted, the script prints an error message and exits.
-  * The script prints an error message if the encrypted data cannot be sent to the server.
-  * If the server cannot receive a response, the script prints an error message.
-  * If any other error occurs, the script prints an error message and exits.
+ If the script cannot create the client socket, it will display an error message and terminate.
+ If the client socket fails to connect to the server, an error message is printed, and the socket is closed.
+ If the script fails to generate or write the encryption key to the file, an error message is printed, and the script exits.
+ If the encryption key cannot be loaded from the file, an error message is printed, and the script exits.
+ If the serialised data cannot be encrypted, the script prints an error message and exits.
+ The script prints an error message if the encrypted data cannot be sent to the server.
+ If the server cannot receive a response, the script prints an error message.
+ If any other error occurs, the script prints an error message and exits.
 
 
 
@@ -198,34 +198,34 @@ Solution Design (Server)
 Python script serverfinal.py is written to receive encrypted data, decrypt it using fernet cryptography and de-serialise using pickle module.
 
 The script operates as follows:
-  * create_server_socket() creates a TCP server socket and binds it to the specified address and port.
+ create_server_socket() creates a TCP server socket and binds it to the specified address and port.
    
    
 
-  * accept_connection() function accepts an incoming connection on the server socket and returns the client socket.
+ accept_connection() function accepts an incoming connection on the server socket and returns the client socket.
    
    
    
-  * load_fernet_key() this function loads the Fernet encryption key from the specified file.
+ load_fernet_key() this function loads the Fernet encryption key from the specified file.
    
    
    
-  * receive_and_decrypt_data() this function receives encrypted data from the client socket, decrypts it using the Fernet key, and returns the decrypted data.
+ receive_and_decrypt_data() this function receives encrypted data from the client socket, decrypts it using the Fernet key, and returns the decrypted data.
    
    
-  * deserialize_data() this function deserialises the decrypted data using the pickle library.
+ deserialize_data() this function deserialises the decrypted data using the pickle library.
    
    
 
-  * save_decrypted_data_to_file() this function saves the deserialised data to the specified file using the pickle library.
+ save_decrypted_data_to_file() this function saves the deserialised data to the specified file using the pickle library.
    
    
    
-  * send_response() this function sends the specified response back to the client socket.
+ send_response() this function sends the specified response back to the client socket.
    
    
    
-  * server_connection() creates a server socket, accepts incoming connection from a client once connection established sends a response back to the client
+ server_connection() creates a server socket, accepts incoming connection from a client once connection established sends a response back to the client
    
    
 
@@ -238,16 +238,16 @@ Error handling for every function is built into the code using the try-except bl
 
 
 Error handling within the script:
-  * Socket errors will result in error messages and exceptions being raised.
-  * If the key file is not found, an error is printed, and an exception is raised.
-  * If the encrypted data cannot be decrypted, the code raises an exception and prints an error.
-  * If the de-serialised data cannot be saved to a file, the code raises an exception and prints an error message.
-  * If an error occurs while sending the response to the client, the code prints an error message and raises an exception.
+ Socket errors will result in error messages and exceptions being raised.
+ If the key file is not found, an error is printed, and an exception is raised.
+ If the encrypted data cannot be decrypted, the code raises an exception and prints an error.
+ If the de-serialised data cannot be saved to a file, the code raises an exception and prints an error message.
+ If an error occurs while sending the response to the client, the code prints an error message and raises an exception.
 Design Decisions
 
 Encryption: Fernet Cryptographic protocol will be used as our encryption tool of choice for the following reasons: 
-  * Fernet uses symmetric key cryptography, which is simple and easy to use.  
-  * Fernet is built on AES (Advance Encryption Standard) and ensures data encrypted is well-protected. 
+ Fernet uses symmetric key cryptography, which is simple and easy to use.  
+ Fernet is built on AES (Advance Encryption Standard) and ensures data encrypted is well-protected. 
 
 
 Unit Testing
@@ -260,8 +260,8 @@ This is done by creating an action flow that defines the steps that should be ta
 Server Unit Testing
 This unit tests are used to test the function within the server script called serverfinal.py. The tests start by creating a key file for testing and then mock functions of serverfinal.py:
 
-  * receive_and_decrypt_data(), which receives encrypted data from a socket and decrypts it using a key.
-  * deserialize_data(), which deserializes a given data and returns a dictionary.
+ receive_and_decrypt_data(), which receives encrypted data from a socket and decrypts it using a key.
+ deserialize_data(), which deserializes a given data and returns a dictionary.
    
 The receive_and_decrypt_data() function receives encrypted data over a socket and decrypts it using a secret key. 
 
@@ -285,12 +285,12 @@ Client Unit Testing
 This unit tests are used to test the function within the server script called clientfinal.py. The test uses the unittest and mock modules to test the functionality of the client (clientfinal.py) module without connecting to a server and send and receive data.
 
 The test case starts by creating a key file for testing. It then mocks the following functions and methods in the clientfinal module:
-  * create_client_socket
-  * connect_to_server
-  * write_key
-  * load_key
-  * encrypt
-  * receive_response
+ create_client_socket
+ connect_to_server
+ write_key
+ load_key
+ encrypt
+ receive_response
    
 
 After the main function has been called, assertions are used to verify that the functions and methods in the clientfinal module are called with the expected arguments. This validates that the code is running as intended. 
@@ -318,6 +318,6 @@ GitHub Action automates client and server unit tests, a crucial CI/CD (Continuou
 Docstrings are added to provide clear explanations of their purpose, arguments, and possible exceptions. The code includes robust exception handling, ensuring errors are caught and handled gracefully. It prints informative error messages when exceptions occur, helping debug and troubleshoot.
 
 Overall, the Group Project demonstrates well-structured secure communication over a TCP connection, featuring organised code, unit testing, automation for continuous integration, and error handling for a reliable and efficient solution.
-REFERENCES
+ REFERENCES
 Joyce, P. (2021) C and Python Applications: Embedding Python Code in C Programs, SQL Methods, and Python Sockets  -  Chapter 6 - Sockets. Berkeley, CA: Apress L. P. Available at: https://doi.org/10.1007/978-1-4842-7774-4
 Xue, M. and Zhu, C., 2009, May. The socket programming and software design for communication based on client/server. In 2009 Pacific-Asia Conference on Circuits, Communications and Systems (pp. 775-777). IEEE.

commit bacf529bc10a761517561c4ed805ae3bf7c76fa3
Author: Olesya <40202074+oshtern@users.noreply.github.com>
Date:   Tue Oct 10 00:03:31 2023 +0700

    Amended the report

diff --git a/Group C - Client Server Network Report.docx b/Group C - Client Server Network Report.docx
index d997424..f56d5b8 100644
--- a/Group C - Client Server Network Report.docx	
+++ b/Group C - Client Server Network Report.docx	
@@ -27,7 +27,7 @@ MASTER-OF-COMPUTER-SCIENCE
 Software Development in Practice
 
 
-Word Count: 2132
+Word Count: 1547
 
 
                                        
@@ -69,7 +69,7 @@ The University of Liverpool
 
 
 
-Word Count: 2132
+Word Count: 1547
 
                                        
 
@@ -98,24 +98,15 @@ Chapter 5. Conclusion	12
 Introduction
 
 The objective of this project is creating a Client Server Network which once established can facilitate the transmission of encrypted and serialised files. Also, the server must have the seamless mechanism for decrypting and processing these files on the server side.    
-SCOPE OF PROJECT
-The code and software architecture report will explain how Group C developed our Client Server Network and deployed it on to the local network. 
-The project needs to have three key functions:
- Capable of Secure Communication between client and server.
- Using Pickle  -  Serialising the data/encryption before transmission from client. 
- Decrypting the data and demonstrating the information in required format by printing it. 
-Purpose of Report                                                                 
 This report and the related code created by Group C will demonstrate the following:
- Understanding of network communication, creation, and manipulation of data structures
- Transmission of data between client and server, 
- Implementation of advanced features such as data serialisation in various formats and encryption of text files.
-
-The Group decided to break this project into four roles of Project Manager, Architect, Developer and Tester to reflect how this project would be managed as a real time project in industry. This will enable Group C to acquire the essential skills for designing and managing networked systems in real-world scenarios whilst gaining an understanding of how data security works and the importance of data privacy using encryption.
+  1. Capable of Secure Communication between client and server.
+  2. Using Pickle  -  Serialising the data/encryption before transmission from client. 
+  3. Decrypting the data and demonstrating the information in required format by printing it. 
 
 Team has a public repository on GitHub which was used throughout the project for collaboration and version control. Team's public repository can be found using this link  -  
 https://github.com/callmehawa/Client_Server_Network_GroupC. [HYPERLINK: https://github.com/callmehawa/Client_Server_Network_GroupC.git]git
 
-Team Member  -  Olesia Shtern, Nika Kapanadze, Paul Coleman and Pawan Thatal
+Team Members  -  Olesia Shtern, Nika Kapanadze, Paul Coleman and Pawan Thatal
 
 
 Solution Overview
@@ -154,46 +145,46 @@ Solution Design (Client)
                                        
 
 
-Python script clientfinal.py is written to serialise a dictionary, encrypt it and send it over to a server using socket programming. Fernet library is used to encrypt the data, pickle module for serialising and socket library to send and receive data over the network. These are imported as below  - 
+Python script serverfinal.py is written to receive encrypted data, decrypt it using fernet cryptography and de-serialise using pickle module.
 
                                         
+The script operates as follows:
+  * A client socket is established by utilising the create_client_socket() function.
+   
+   
+  * Connects to the server using the connect_to_server() function.
+   
+   
+  * New encryption key is generated and written to a file using the write_key() function.
+   
+   
+   
+  * Encryption key is loaded from the file using the load_key() function
+   
 
-The script is organised into functions, making it readable, maintainable, available for reuse and isolated for effective unit testing.
-
-
-The script includes comments and docstrings describing each function's purpose and what it does.
-
-
-
-
-
-
-Error handling for every function is built into the code using the try-except block.
-
-
+  * The pickle module converts a dictionary into binary format for easy storage and transfer.
+   
+   
+  * The data is serialised and then encrypted using the encrypt() function.
+   
+   
+  * The data is encrypted and sent to the server using the send_encrypted_data() function
+   
 
-The script operates as follows:
- A client socket is established by utilising the create_client_socket() function.
- Connects to the server using the connect_to_server() function.
- New encryption key is generated and written to a file using the write_key() function.
- Encryption key is loaded from the file using the load_key() function.
- The pickle module converts a dictionary into binary format for easy storage and transfer.
- The data is serialised and then encrypted using the encrypt() function.
- The data is encrypted and sent to the server using the send_encrypted_data() function.
- The function receive_response() is utilised to obtain a response from the server.
- After receiving a response, the system decodes it and displays it on the console as a response from the server.
- Before exiting, the script ensures that the client socket is closed.
+  * The function receive_response() is utilised to obtain a response from the server.
+  * After receiving a response, the system decodes it and displays it on the console as a response from the server.
+  * Before exiting, the script ensures that the client socket is closed.
 
 Error handling within the script:
 
- If the script cannot create the client socket, it will display an error message and terminate.
- If the client socket fails to connect to the server, an error message is printed, and the socket is closed.
- If the script fails to generate or write the encryption key to the file, an error message is printed, and the script exits.
- If the encryption key cannot be loaded from the file, an error message is printed, and the script exits.
- If the serialised data cannot be encrypted, the script prints an error message and exits.
- The script prints an error message if the encrypted data cannot be sent to the server.
- If the server cannot receive a response, the script prints an error message.
- If any other error occurs, the script prints an error message and exits.
+  * If the script cannot create the client socket, it will display an error message and terminate.
+  * If the client socket fails to connect to the server, an error message is printed, and the socket is closed.
+  * If the script fails to generate or write the encryption key to the file, an error message is printed, and the script exits.
+  * If the encryption key cannot be loaded from the file, an error message is printed, and the script exits.
+  * If the serialised data cannot be encrypted, the script prints an error message and exits.
+  * The script prints an error message if the encrypted data cannot be sent to the server.
+  * If the server cannot receive a response, the script prints an error message.
+  * If any other error occurs, the script prints an error message and exits.
 
 
 
@@ -204,44 +195,42 @@ Solution Design (Server)
 
 
 
-Python script serverfinal.py is written to receive encrypted serialised data from the client. It uses the socket module to create a server socket and accept incoming connections. It then uses the cryptography.fernet module to decrypt the data using a Fernet key. 
-
-Finally, it uses the pickle module to deserialise the data and save it to a file. The script includes comments and docstrings describing each function's purpose and what it does. 
+Python script serverfinal.py is written to receive encrypted data, decrypt it using fernet cryptography and de-serialise using pickle module.
 
 The script operates as follows:
- create_server_socket() creates a TCP server socket and binds it to the specified address and port.
+  * create_server_socket() creates a TCP server socket and binds it to the specified address and port.
    
    
 
- accept_connection() function accepts an incoming connection on the server socket and returns the client socket.
+  * accept_connection() function accepts an incoming connection on the server socket and returns the client socket.
    
    
    
- load_fernet_key() this function loads the Fernet encryption key from the specified file.
+  * load_fernet_key() this function loads the Fernet encryption key from the specified file.
    
    
    
- receive_and_decrypt_data() this function receives encrypted data from the client socket, decrypts it using the Fernet key, and returns the decrypted data.
+  * receive_and_decrypt_data() this function receives encrypted data from the client socket, decrypts it using the Fernet key, and returns the decrypted data.
    
    
- deserialize_data() this function deserialises the decrypted data using the pickle library.
+  * deserialize_data() this function deserialises the decrypted data using the pickle library.
    
    
 
- save_decrypted_data_to_file() this function saves the deserialised data to the specified file using the pickle library.
+  * save_decrypted_data_to_file() this function saves the deserialised data to the specified file using the pickle library.
    
    
    
- send_response() this function sends the specified response back to the client socket.
+  * send_response() this function sends the specified response back to the client socket.
    
    
    
- server_connection() this function is the main entry point for the server. It creates a server socket, accepts incoming connection from a client once connection established sends a response back to the client
+  * server_connection() creates a server socket, accepts incoming connection from a client once connection established sends a response back to the client
    
    
 
- Once a successful connection is established `try' block will be executed which has the main logic of the server and will call functions to create server socket, load fernet key, de-serialise and decrypt data. Once complete it will ask user for an output option of `print' or `save'.
-   
+Once the connection is established, the main logic of the server will execute in the 'try' block. Functions will create a server socket, load the fernet key, and decrypt data. Then, the user will choose to either 'print' or 'save' the output.
+
    
  
 Error handling for every function is built into the code using the try-except block.
@@ -249,16 +238,16 @@ Error handling for every function is built into the code using the try-except bl
 
 
 Error handling within the script:
- Socket errors will result in error messages and exceptions being raised.
- If the key file is not found, an error is printed, and an exception is raised.
- If the encrypted data cannot be decrypted, the code raises an exception and prints an error.
- If the de-serialised data cannot be saved to a file, the code raises an exception and prints an error message.
- If an error occurs while sending the response to the client, the code prints an error message and raises an exception.
+  * Socket errors will result in error messages and exceptions being raised.
+  * If the key file is not found, an error is printed, and an exception is raised.
+  * If the encrypted data cannot be decrypted, the code raises an exception and prints an error.
+  * If the de-serialised data cannot be saved to a file, the code raises an exception and prints an error message.
+  * If an error occurs while sending the response to the client, the code prints an error message and raises an exception.
 Design Decisions
 
-Encryption: Fernet Cryptographic protocol will be used as our encryption tool of choice for the following reasons - 
- Fernet uses symmetric key cryptography, which is simple and easy to use.  
- Fernet is built on AES (Advance Encryption Standard) and ensures data encrypted is well-protected. 
+Encryption: Fernet Cryptographic protocol will be used as our encryption tool of choice for the following reasons: 
+  * Fernet uses symmetric key cryptography, which is simple and easy to use.  
+  * Fernet is built on AES (Advance Encryption Standard) and ensures data encrypted is well-protected. 
 
 
 Unit Testing
@@ -269,10 +258,10 @@ Unit testing is essential for maintaining code quality, reducing bugs, and suppo
 
 This is done by creating an action flow that defines the steps that should be taken when code is pushed to a branch. In this instance, the workflow will run either unit_tests_client.py or unit_tests_server.py every time code is pushed or pulled from any branch within the repository. Running unit tests every time code is committed using GitHub Actions, helps in early detection of bugs and improves quality.
 Server Unit Testing
-This unit tests are used to test the function within the server script called serverfinal.py. The tests status by creating a key file for testing and then mocks functions of serverfinal.py:
+This unit tests are used to test the function within the server script called serverfinal.py. The tests start by creating a key file for testing and then mock functions of serverfinal.py:
 
- receive_and_decrypt_data(), which receives encrypted data from a socket and decrypts it using a key.
- deserialize_data(), which deserializes a given data and returns a dictionary.
+  * receive_and_decrypt_data(), which receives encrypted data from a socket and decrypts it using a key.
+  * deserialize_data(), which deserializes a given data and returns a dictionary.
    
 The receive_and_decrypt_data() function receives encrypted data over a socket and decrypts it using a secret key. 
 
@@ -296,12 +285,12 @@ Client Unit Testing
 This unit tests are used to test the function within the server script called clientfinal.py. The test uses the unittest and mock modules to test the functionality of the client (clientfinal.py) module without connecting to a server and send and receive data.
 
 The test case starts by creating a key file for testing. It then mocks the following functions and methods in the clientfinal module:
- create_client_socket
- connect_to_server
- write_key
- load_key
- encrypt
- receive_response
+  * create_client_socket
+  * connect_to_server
+  * write_key
+  * load_key
+  * encrypt
+  * receive_response
    
 
 After the main function has been called, assertions are used to verify that the functions and methods in the clientfinal module are called with the expected arguments. This validates that the code is running as intended. 
@@ -312,17 +301,11 @@ The test case then prints a custom message of the outcome of the test.
 
 
 
-
-
 Conclusion
 
-The Group Project was to create a secure way to communicate with a server over a TCP connection. 
-
-The client code establishes a connection with the server, generates and shares a Fernet encryption key, encrypts and sends data to the server, and receives and prints a response. Python's pickle module is used to serialise before encryption, allowing complex data structures to be sent securely over the network. The code uses the Fernet encryption algorithm, a potent and widely accepted method for securing data during transmission.
-
-The server code establishes a connection with the client, receives and decrypts encrypted data using the shared Fernet key, de-serialises the data using the pickle module, saves the decrypted data to a file, or prints the file based on use input and responds to the client. The code includes exception handling, ensuring errors are caught and, informative error messages are printed when exceptions occur, and helping debug and troubleshoot.
+The Group Project was creating a simple Client server network and send data securely over a network.  
 
-Both client and server code are organised into functions with specific purposes to make the code easier to read and maintain and allow for better testing of individual components. 
+Both Client and Server code are organised into functions for each specific tasks. Functions make code more readable and easier to understand by breaking it down into smaller, logical chunks. Functions make the code easier to test. 
 
 Similarly, unit testing code is organised into separate test classes for the server and client scripts. This method tests a specific function in isolation that helps identify precisely where the failures occur. 
 

commit e913d7bc6ed99a48c937e86220b83231189a4c6e
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Mon Oct 9 11:46:18 2023 +0100

    deleted file generated during testing

diff --git a/decrypted_dict.pickle b/decrypted_dict.pickle
deleted file mode 100644
index 1da61cf..0000000
Binary files a/decrypted_dict.pickle and /dev/null differ
diff --git a/dict.pickle b/dict.pickle
deleted file mode 100644
index 1da61cf..0000000
Binary files a/dict.pickle and /dev/null differ
diff --git a/key.key b/key.key
deleted file mode 100644
index b61ba88..0000000
--- a/key.key
+++ /dev/null
@@ -1 +0,0 @@
-FN49Os_LAIGSXdVoGBF_LMhUzz8HVHADBYMgpKU4ZIA=
\ No newline at end of file

commit e91e5713cac959e0002d727ede16274cb2b8a1b6
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Mon Oct 9 11:12:14 2023 +0100

    removed print statement after de-serialsiaton

diff --git a/serverfinal.py b/serverfinal.py
index 35217be..3841f8a 100644
--- a/serverfinal.py
+++ b/serverfinal.py
@@ -113,7 +113,7 @@ def deserialize_data(data):
     
     try:
         deserialized_data = pickle.loads(data)
-        print("Deserialized data:", deserialized_data)
+        #print("Deserialized data:", deserialized_data)
         return deserialized_data
     except pickle.PickleError as e:
         print("Error deserializing data:", e)

commit e5bf3e35f260d8929c48ec5b6a54f4b49ddb6d61
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Sun Oct 8 21:55:19 2023 +0100

    added team members list. Added print or save in output on server design. Re-wrote conclusion

diff --git a/Group C - Client Server Network Report.docx b/Group C - Client Server Network Report.docx
index 2681480..d997424 100644
--- a/Group C - Client Server Network Report.docx	
+++ b/Group C - Client Server Network Report.docx	
@@ -27,7 +27,7 @@ MASTER-OF-COMPUTER-SCIENCE
 Software Development in Practice
 
 
-Word Count: XXX
+Word Count: 2132
 
 
                                        
@@ -69,7 +69,7 @@ The University of Liverpool
 
 
 
-Word Count: XXX
+Word Count: 2132
 
                                        
 
@@ -83,18 +83,14 @@ Chapter 1. Introduction	2
 Chapter 2. Solution Overview	3
 2.1	Solution overview	3
 2.2	Technical Flow	4
-Chapter 3. Solution Design (Client)	5
-3.1	Solution Design (Server)	5
-3.2	Solution Design (Server)	5
-3.3	Error Handling	6
-3.4	Design Decisions	6
-Chapter 4. Testing	6
-4.1	Serialization Unit Testing	6
-4.2	Encryption Unit Testing	6
-4.3	Network Unit Testing	6
-Chapter 5. Conclusion	7
-REFERENCES	8
-APPENDICES	8
+Chapter 3. Solution Design	5
+3.1	Solution Design (Client)	5
+3.2	Solution Design (Server)	7
+3.3	Design Decisions	9
+Chapter 4. Unit Testing	9
+4.1	Server Unit Testing	10
+4.2	Client Unit Testing	11
+Chapter 5. Conclusion	12
 
                     
 
@@ -113,13 +109,13 @@ This report and the related code created by Group C will demonstrate the followi
  Understanding of network communication, creation, and manipulation of data structures
  Transmission of data between client and server, 
  Implementation of advanced features such as data serialisation in various formats and encryption of text files.
-   
+
 The Group decided to break this project into four roles of Project Manager, Architect, Developer and Tester to reflect how this project would be managed as a real time project in industry. This will enable Group C to acquire the essential skills for designing and managing networked systems in real-world scenarios whilst gaining an understanding of how data security works and the importance of data privacy using encryption.
 
 Team has a public repository on GitHub which was used throughout the project for collaboration and version control. Team's public repository can be found using this link  -  
 https://github.com/callmehawa/Client_Server_Network_GroupC. [HYPERLINK: https://github.com/callmehawa/Client_Server_Network_GroupC.git]git
 
-Team Member - 
+Team Member  -  Olesia Shtern, Nika Kapanadze, Paul Coleman and Pawan Thatal
 
 
 Solution Overview
@@ -215,22 +211,37 @@ Finally, it uses the pickle module to deserialise the data and save it to a file
 The script operates as follows:
  create_server_socket() creates a TCP server socket and binds it to the specified address and port.
    
+   
+
  accept_connection() function accepts an incoming connection on the server socket and returns the client socket.
    
+   
+   
  load_fernet_key() this function loads the Fernet encryption key from the specified file.
    
+   
+   
  receive_and_decrypt_data() this function receives encrypted data from the client socket, decrypts it using the Fernet key, and returns the decrypted data.
    
+   
  deserialize_data() this function deserialises the decrypted data using the pickle library.
    
+   
+
  save_decrypted_data_to_file() this function saves the deserialised data to the specified file using the pickle library.
    
+   
+   
  send_response() this function sends the specified response back to the client socket.
    
- server_connection() this function is the main entry point for the server. It creates a server socket, accepts a connection from a client, loads the Fernet key, receives and decrypts the data from the client, deserialises the data, saves it to a file, and then sends a response back to the client.
+   
+   
+ server_connection() this function is the main entry point for the server. It creates a server socket, accepts incoming connection from a client once connection established sends a response back to the client
+   
    
 
- Once a successful connection is established `try' block will be executed which has the main logic of the server and will call functions to create server socket, load fernet key, de-serialise and decrypt data. Once complete it will as user or an output option of `print' or `save'.
+ Once a successful connection is established `try' block will be executed which has the main logic of the server and will call functions to create server socket, load fernet key, de-serialise and decrypt data. Once complete it will ask user for an output option of `print' or `save'.
+   
    
  
 Error handling for every function is built into the code using the try-except block.
@@ -251,9 +262,12 @@ Encryption: Fernet Cryptographic protocol will be used as our encryption tool of
 
 
 Unit Testing
- Unit testing is essential for maintaining code quality, reducing bugs, and supporting code changes. We have used GitHub Actions, a CI/CD platform, to run unit tests every time code is committed to a GitHub repository. 
- 
- This is done by creating an action flow that defines the steps that should be taken when code is pushed to a branch. In this instance, the workflow will run either unit_tests_client.py or unit_tests_server.py every time code is pushed or pulled from any branch within the repository. Running unit tests every time code is committed using GitHub Actions, helps in early detection of bugs and improves quality.
+
+Unit testing is essential for maintaining code quality, reducing bugs, and supporting code changes. We have used GitHub Actions, a CI/CD platform, to run unit tests every time code is committed to a GitHub repository. 
+
+
+
+This is done by creating an action flow that defines the steps that should be taken when code is pushed to a branch. In this instance, the workflow will run either unit_tests_client.py or unit_tests_server.py every time code is pushed or pulled from any branch within the repository. Running unit tests every time code is committed using GitHub Actions, helps in early detection of bugs and improves quality.
 Server Unit Testing
 This unit tests are used to test the function within the server script called serverfinal.py. The tests status by creating a key file for testing and then mocks functions of serverfinal.py:
 
@@ -300,43 +314,27 @@ The test case then prints a custom message of the outcome of the test.
 
 
 
-
 Conclusion
-Summary
-The aim of this group project was to creating a Client Server Network can facilitate the transmission of encrypted and serialised files. Also, the server must have the capability to decrypt and process the files on the server side.    
-Milestones
-We achieved four significant milestones with this project:
- Group C was able to integrate as a team on the project. 
- Client file able to send a text file serialized and encrypted 
- Client Server was set up to deserialise and decrypt. 
- Unit Testing successfully run and no errors found. 
-Results of the code 
-Please can someone do  -  2 lines on results of code - XXXXXXXXXXXXXX
-Assignment challenges
- Each individual of Group C did not come from a coding background so we had to research a lot of the concepts  -  do we need to reference our research? Websites  -  Linkedin learning/W3/Google?
- We did not have familiarity with how Github repository works for a group project so we had working session provided by Pawan on how it works. We learnt how to conduct pull requests, committing to the repository 
- XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
-Acknowledgements
-Nika
-Olesia
-Paul
-Pawan
-Brett for his guidance?
-Conclusion 
-What did this project achieve?  -  Thoughts-  Maybe we need to outline in (1/2) lines what the project achieved  -  Data encryption and security???
 
-REFERENCES
-Joyce, P. (2021) C and Python Applications: Embedding Python Code in C Programs, SQL Methods, and Python Sockets  -  Chapter 6 - Sockets. Berkeley, CA: Apress L. P. Available at: https://doi.org/10.1007/978-1-4842-7774-4
-Xue, M. and Zhu, C., 2009, May. The socket programming and software design for communication based on client/server. In 2009 Pacific-Asia Conference on Circuits, Communications and Systems (pp. 775-777). IEEE.
+The Group Project was to create a secure way to communicate with a server over a TCP connection. 
 
+The client code establishes a connection with the server, generates and shares a Fernet encryption key, encrypts and sends data to the server, and receives and prints a response. Python's pickle module is used to serialise before encryption, allowing complex data structures to be sent securely over the network. The code uses the Fernet encryption algorithm, a potent and widely accepted method for securing data during transmission.
 
+The server code establishes a connection with the client, receives and decrypts encrypted data using the shared Fernet key, de-serialises the data using the pickle module, saves the decrypted data to a file, or prints the file based on use input and responds to the client. The code includes exception handling, ensuring errors are caught and, informative error messages are printed when exceptions occur, and helping debug and troubleshoot.
 
+Both client and server code are organised into functions with specific purposes to make the code easier to read and maintain and allow for better testing of individual components. 
 
-APPENDICES 
-	
- GitHub Repository - 
- Client Server Network Project report
- Requirement.txt
- Readme.md
- Screenshot of Github repo
- Screenshot of Logs
+Similarly, unit testing code is organised into separate test classes for the server and client scripts. This method tests a specific function in isolation that helps identify precisely where the failures occur. 
+
+The code uses the mock module to mock external dependencies like sockets and cryptography functions. This allows the tests to focus on the specific functionality being tested without involving the actual external resources. 
+
+Test code includes a summary that provides a clear overview of what was tested and the outcome and helps quickly understand the test results.
+
+GitHub Action automates client and server unit tests, a crucial CI/CD (Continuous Integration/Continuous Delivery) pipeline component. It ensures that code changes are tested automatically upon each commit, preventing integration issues and allowing faster, more reliable deployments. This helps to improve code quality and catch regressions early in the development cycle. 
+
+Docstrings are added to provide clear explanations of their purpose, arguments, and possible exceptions. The code includes robust exception handling, ensuring errors are caught and handled gracefully. It prints informative error messages when exceptions occur, helping debug and troubleshoot.
+
+Overall, the Group Project demonstrates well-structured secure communication over a TCP connection, featuring organised code, unit testing, automation for continuous integration, and error handling for a reliable and efficient solution.
+REFERENCES
+Joyce, P. (2021) C and Python Applications: Embedding Python Code in C Programs, SQL Methods, and Python Sockets  -  Chapter 6 - Sockets. Berkeley, CA: Apress L. P. Available at: https://doi.org/10.1007/978-1-4842-7774-4
+Xue, M. and Zhu, C., 2009, May. The socket programming and software design for communication based on client/server. In 2009 Pacific-Asia Conference on Circuits, Communications and Systems (pp. 775-777). IEEE.
diff --git a/decrypted_dict.pickle b/decrypted_dict.pickle
new file mode 100644
index 0000000..1da61cf
Binary files /dev/null and b/decrypted_dict.pickle differ
diff --git a/dict.pickle b/dict.pickle
new file mode 100644
index 0000000..1da61cf
Binary files /dev/null and b/dict.pickle differ
diff --git a/key.key b/key.key
new file mode 100644
index 0000000..b61ba88
--- /dev/null
+++ b/key.key
@@ -0,0 +1 @@
+FN49Os_LAIGSXdVoGBF_LMhUzz8HVHADBYMgpKU4ZIA=
\ No newline at end of file

commit 234e8bb14f27d1cff609e85b3efd392fb0a6752b
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Sun Oct 8 21:54:33 2023 +0100

    removed print statement from save_decrypted_data_to_file function

diff --git a/serverfinal.py b/serverfinal.py
index 6980b30..35217be 100644
--- a/serverfinal.py
+++ b/serverfinal.py
@@ -140,7 +140,7 @@ def save_decrypted_data_to_file(data, file_path):
     try:
         with open(file_path, 'wb') as file:
             pickle.dump(data, file)
-        #print("Data saved to file:", file_path)
+        
     except Exception as e:
         print("Error saving data to file:", e)
         raise

commit c8892a28cba39ac826e790a1e87b977e1ad52f1f
Author: nicolasKappa <nicola.kappa8@gmail.com>
Date:   Sun Oct 8 15:03:48 2023 +0400

    I have updated doctrsing/ comments for Serverfinal

diff --git a/clientfinal.py b/clientfinal.py
index 1d792b3..9018e8d 100644
--- a/clientfinal.py
+++ b/clientfinal.py
@@ -1,8 +1,27 @@
+
+"""
+This script establishes a TCP connection with a server, generates and shares a Fernet encryption key, 
+encrypts and sends data to the server, and receives and prints a response.
+
+"""
+
+# import necessary modules
 import socket
 import pickle
 from cryptography.fernet import Fernet
 
 def create_client_socket():
+    
+    """
+    Create a client socket.
+
+    Returns:
+        socket.socket or None: The created client socket, or None if there is an error creating the socket.
+
+    Raises:
+        socket.error: If there's an error creating the socket.
+    """
+    
     try:
         client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
         return client_socket
@@ -11,6 +30,18 @@ def create_client_socket():
         return None
 
 def connect_to_server(client_socket, server_address):
+    
+    """
+    Connect the client socket to the specified server address.
+
+    Args:
+        client_socket : The client socket to connect.
+        server_address : Containing the server's address (IP, port).
+
+    Raises:
+        socket.error: If there's an error connecting to the server.
+    """
+    
     try:
         client_socket.connect(server_address)
     except socket.error as e:
@@ -18,6 +49,17 @@ def connect_to_server(client_socket, server_address):
         client_socket.close()
 
 def write_key(key_filename="key.key"):
+    
+    """
+    Generate a Fernet key and write it to a file.
+
+    Args:
+        key_filename : The filename to save the key. Default is "key.key".
+
+    Raises:
+        Exception: If there's an error generating or writing the key.
+    """
+ 
     try:
         key = Fernet.generate_key()
         with open(key_filename, "wb") as key_file:
@@ -26,6 +68,21 @@ def write_key(key_filename="key.key"):
         print(f"Key generation and writing error: {e}")
 
 def load_key(key_filename="key.key"):
+    
+    """
+    Load a Fernet key from a file.
+
+    Args:
+        key_filename : The filename from which to load the key. Default is "key.key".
+
+    Returns:
+        bytes or None: The loaded Fernet key, or None if there is an error loading the key.
+
+    Raises:
+        FileNotFoundError: If the key file is not found.
+        Exception: If there's an error loading the key.
+    """
+    
     try:
         key = open(key_filename, "rb").read()
         return key
@@ -37,6 +94,21 @@ def load_key(key_filename="key.key"):
         return None
 
 def encrypt(data, key):
+   
+    """
+    Encrypt data using a Fernet key.
+
+    Args:
+        data : The data to be encrypted.
+        key : The Fernet key.
+
+    Returns:
+        bytes or None: The encrypted data, or None if there is an error during encryption.
+
+    Raises:
+        Exception: If there's an error during encryption.
+    """
+    
     try:
         f = Fernet(key)
         encrypted_data = f.encrypt(data)
@@ -60,6 +132,21 @@ def send_encrypted_data(client_socket, encrypted_data):
         print(f"Data sending error: {e}")
 
 def receive_response(client_socket, buffer_size=1024):
+    
+    """
+    Receive a response from the server.
+
+    Args:
+        client_socket : The client socket.
+        buffer_size : The size of the buffer for receiving data. Default is 1024.
+
+    Returns:
+        str or None: The received response as a string, or None if there is an error receiving data.
+
+    Raises:
+        socket.error: If there's an error receiving data.
+    """
+    
     try:
         response = client_socket.recv(buffer_size)
         return response.decode('utf-8')
@@ -68,6 +155,25 @@ def receive_response(client_socket, buffer_size=1024):
         return None
 
 def main():
+
+    """
+    Main function for client-side communication with the server.
+
+    This function performs the following steps:
+    1. Creates a client socket.
+    2. Connects to the server at the specified address.
+    3. Generates and writes a Fernet key to a file.
+    4. Loads the Fernet key.
+    5. Creates a dictionary, serializes it, and encrypts the data.
+    6. Sends the encrypted data to the server.
+    7. Receives and prints a response from the server.
+
+    If any error occurs during these steps, it will be caught and an error message will be printed.
+
+    Returns:
+        None
+    """
+
     try:
         client_socket = create_client_socket()
         if client_socket is None:
@@ -107,5 +213,6 @@ def main():
         if client_socket is not None:
             client_socket.close()
 
+# call main function if script if code is executed directly
 if __name__ == '__main__':
     main()
diff --git a/serverfinal.py b/serverfinal.py
index c66bcc1..6980b30 100644
--- a/serverfinal.py
+++ b/serverfinal.py
@@ -119,7 +119,7 @@ def deserialize_data(data):
         print("Error deserializing data:", e)
         raise
 
-def save_decrypted_data_to_filec(data, file_path):
+def save_decrypted_data_to_file(data, file_path):
 
     """
     Save decrypted data to a file.

commit 1bb8a1ceb8a56f68f1072c4facb226d5715eea9f
Author: Paul Coleman <colemanp54@icloud.com>
Date:   Sun Oct 8 11:36:38 2023 +0100

    DocString Commit Changes

commit 8cbeb9e7b21851accdb7995d9229707a3e6c0680
Author: Paul Coleman <colemanp54@icloud.com>
Date:   Sun Oct 8 11:36:08 2023 +0100

    Committing Doc Strings changes

diff --git a/serverfinal.py b/serverfinal.py
index c627a98..c66bcc1 100644
--- a/serverfinal.py
+++ b/serverfinal.py
@@ -13,7 +13,7 @@ It is a secure way to perform encryption and decryption using a shared secret ke
 def create_server_socket(address, port):
 
     """
-    Created a socket server that is open to listening for connections from clients.
+    We created a socket server that is open to listening for connections from client.
     """
     try:
         server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

commit 81e24e74c148113a8433b381dc377cfa4adb9313
Author: Paul Coleman <colemanp54@icloud.com>
Date:   Sun Oct 8 10:25:37 2023 +0100

    Concul and reference changes

diff --git a/Group C - Client Server Network Report.docx b/Group C - Client Server Network Report.docx
index 7cfdf13..2681480 100644
--- a/Group C - Client Server Network Report.docx	
+++ b/Group C - Client Server Network Report.docx	
@@ -323,8 +323,7 @@ Paul
 Pawan
 Brett for his guidance?
 Conclusion 
-What did this project achieve?  -  Thoughts-  Maybe we need to outline in (1/2) lines what the project achieved  -  Data encryption and security?
-
+What did this project achieve?  -  Thoughts-  Maybe we need to outline in (1/2) lines what the project achieved  -  Data encryption and security???
 
 REFERENCES
 Joyce, P. (2021) C and Python Applications: Embedding Python Code in C Programs, SQL Methods, and Python Sockets  -  Chapter 6 - Sockets. Berkeley, CA: Apress L. P. Available at: https://doi.org/10.1007/978-1-4842-7774-4

commit 67d14b2b6e1cc001fb05e2d317d53980b3d083c4
Author: Paul Coleman <colemanp54@icloud.com>
Date:   Sun Oct 8 10:14:09 2023 +0100

    Concul_References changes

diff --git a/Group C - Client Server Network Report.docx b/Group C - Client Server Network Report.docx
index 8c11bb9..7cfdf13 100644
--- a/Group C - Client Server Network Report.docx	
+++ b/Group C - Client Server Network Report.docx	
@@ -302,7 +302,33 @@ The test case then prints a custom message of the outcome of the test.
 
 
 Conclusion
+Summary
+The aim of this group project was to creating a Client Server Network can facilitate the transmission of encrypted and serialised files. Also, the server must have the capability to decrypt and process the files on the server side.    
+Milestones
+We achieved four significant milestones with this project:
+ Group C was able to integrate as a team on the project. 
+ Client file able to send a text file serialized and encrypted 
+ Client Server was set up to deserialise and decrypt. 
+ Unit Testing successfully run and no errors found. 
+Results of the code 
+Please can someone do  -  2 lines on results of code - XXXXXXXXXXXXXX
+Assignment challenges
+ Each individual of Group C did not come from a coding background so we had to research a lot of the concepts  -  do we need to reference our research? Websites  -  Linkedin learning/W3/Google?
+ We did not have familiarity with how Github repository works for a group project so we had working session provided by Pawan on how it works. We learnt how to conduct pull requests, committing to the repository 
+ XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
+Acknowledgements
+Nika
+Olesia
+Paul
+Pawan
+Brett for his guidance?
+Conclusion 
+What did this project achieve?  -  Thoughts-  Maybe we need to outline in (1/2) lines what the project achieved  -  Data encryption and security?
+
+
 REFERENCES
+Joyce, P. (2021) C and Python Applications: Embedding Python Code in C Programs, SQL Methods, and Python Sockets  -  Chapter 6 - Sockets. Berkeley, CA: Apress L. P. Available at: https://doi.org/10.1007/978-1-4842-7774-4
+Xue, M. and Zhu, C., 2009, May. The socket programming and software design for communication based on client/server. In 2009 Pacific-Asia Conference on Circuits, Communications and Systems (pp. 775-777). IEEE.
 
 
 

commit c7c035b8912bd0409bc2fec6ae7d47bdefca3593
Merge: 8d4abb3 1dc37a8
Author: saorscarr <144169059+saorscarr@users.noreply.github.com>
Date:   Sun Oct 8 07:46:54 2023 +0100

    Merge pull request #8 from callmehawa/readme_add_errors_handling
    
    Readme add errors handling - All Ok.

commit 8d4abb3868c28c363ea697802438124cc0b61d06
Merge: 3bd2acc 66439cd
Author: Paul Coleman <colemanp54@icloud.com>
Date:   Sun Oct 8 07:44:33 2023 +0100

    Merge branch 'main' of https://github.com/callmehawa/Client_Server_Network_GroupC

commit 3bd2acc36b51fffdeb37424740793f8fa1289b3a
Author: Paul Coleman <colemanp54@icloud.com>
Date:   Sun Oct 8 07:44:25 2023 +0100

    Committing my docstrings on ServerFinal

diff --git a/serverfinal.py b/serverfinal.py
index 1ec0db5..c627a98 100644
--- a/serverfinal.py
+++ b/serverfinal.py
@@ -2,7 +2,19 @@ import socket
 import pickle
 from cryptography.fernet import Fernet
 
+"""
+We are using Fernet encryption algorithm 
+The Fernet class from the cryptography library.
+
+Fernet is an implementation of authenticated cryptography.
+It is a secure way to perform encryption and decryption using a shared secret key.
+"""
+
 def create_server_socket(address, port):
+
+    """
+    Created a socket server that is open to listening for connections from clients.
+    """
     try:
         server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
         server_socket.bind((address, port))
@@ -22,7 +34,28 @@ def accept_connection(server_socket):
         print("Error accepting connection:", e)
         raise
 
+    """
+    accept_connection allows the client to connect and if there is an error prints socket server error message.
+    """
+
 def load_fernet_key(key_file_path):
+    
+    """
+    Loads a Fernet Encryption key from a file.
+
+    This function reads the Fernet encryption key from the path set up.
+
+    Args:
+    key_file_path (str): The path to the file containing the Fernet encryption key.
+
+    Returns:
+    bytes: The Fernet encryption key loaded from the file.
+
+    Raises:
+    FileNotFoundError: If the specified file does not exist.
+
+    """
+
     try:
         with open(key_file_path, "rb") as key_file:
             key = key_file.read()
@@ -35,7 +68,28 @@ def load_fernet_key(key_file_path):
         print("Error loading key:", e)
         raise
 
+    
 def receive_and_decrypt_data(client_socket, key):
+    
+    """
+    Receive and decrypt encrypted data using a decryption key.
+
+    This function takes encrypted data and a decryption key as input and
+    decrypts the data using the Fernet encryption algorithm.
+    The decrypted data is returned.
+
+    Args:
+        encrypted_data : The encrypted data to be decrypted.
+        decryption_key : The Fernet decryption key used for decryption.
+
+    Returns:
+        The decrypted data.
+
+    Raises:
+        cryptography.fernet.InvalidToken: If the decryption fails due to an
+            invalid or expired decryption key.
+    """
+
     try:
         encrypted_data = client_socket.recv(1024)
         print("Received encrypted_data: ", encrypted_data)
@@ -49,6 +103,14 @@ def receive_and_decrypt_data(client_socket, key):
         raise
 
 def deserialize_data(data):
+
+    """
+    
+    Deserialise the serialised data from the client data in an object from Python.
+    The function takes the data, from pickle and deserialises it into a Python object.
+    
+    """
+    
     try:
         deserialized_data = pickle.loads(data)
         print("Deserialized data:", deserialized_data)
@@ -57,7 +119,24 @@ def deserialize_data(data):
         print("Error deserializing data:", e)
         raise
 
-def save_decrypted_data_to_file(data, file_path):
+def save_decrypted_data_to_filec(data, file_path):
+
+    """
+    Save decrypted data to a file.
+
+    This function takes decrypted data and saves it to a specified file using pickle. The
+    decrypted data is in a text file. We have specified where the file will be saved. 
+
+    Args:
+        decrypted_data (bytes or str): The decrypted data to be saved.
+        output_file_path (str): The path to the output file where the data will be saved.
+
+    Raises:
+        Exception: If an error occurs while saving the data to the file, it is raised.
+
+    Returns:
+        Error Statement
+    """
     try:
         with open(file_path, 'wb') as file:
             pickle.dump(data, file)
@@ -67,18 +146,41 @@ def save_decrypted_data_to_file(data, file_path):
         raise
 
 def send_response(client_socket, response):
+
+    """
+    Send a response to a client socket.
+    This function sends a response message to a connected client socket
+
+    Args:
+        client_socket (socket.socket): The client socket object to which the response will be sent.
+        response (str): The response message to send to the client.
+
+    Raise:
+
+        Prints the error message if no response.
+    """
     try:
         client_socket.send(response.encode('utf-8'))
     except socket.error as e:
         print("Error sending response:", e)
         raise
 
+    
 def server_connection(
     server_address='localhost',
     server_port=12345,
     key_file_path='key.key',
     decrypted_data_file_path='decrypted_dict.pickle'
 ):
+    
+    """
+    Establish a connection to a remote server.
+
+    This function establishes a network connection to a remote server using
+    the specified host and port. It creates a socket and attempts to connect
+    to the server.
+    """
+
     server_socket = None
     client_socket = None
 

commit 1dc37a887c5b31a161e57bc4ac951bd62fbb2eec
Author: Olesya <40202074+oshtern@users.noreply.github.com>
Date:   Sat Oct 7 11:31:29 2023 +0300

    Update README.md
    
    Added info on error handling into README

diff --git a/README.md b/README.md
index 2d309ed..0d5e4e4 100644
--- a/README.md
+++ b/README.md
@@ -7,7 +7,7 @@ The server will receive the file, decrypt, deserialise it and print the file
 ## Creating a file
 
 First, we need to initialize the file we are going to work with:
-```
+```python
 dictionary = {"name": "Pawan", "age": 40, "city": "Preston"}
 with open('dict.pickle', 'wb') as file:
     pickle.dump(dictionary, file)
@@ -15,32 +15,32 @@ with open('dict.pickle', 'wb') as file:
 ## File encryption
 
 We can encrypt the file by generating a key first and saving it:
-```
+```python
 def write_key():
     key = Fernet.generate_key()
     with open("key.key", "wb") as key_file:
         key_file.write(key)
 ```
 After this, we need to load this key:
-```
+```python
 def load_key():
     return open("key.key", "rb").read()
 ```
 Generating a new key:
-```
+```python
 write_key()
 key = load_key()
 message = "some secret message".encode()
 ```
 Here we are encrypting the message and printing it out:
-```
+```python
 f = Fernet(key)
 encrypted = f.encrypt(message)
 print(encrypted)
 ```
 
 The process of encrypting the file, reading the file data and writing the encrypted file:
-```
+```python
 def encrypt(filename, key):
     f = Fernet(key)
     with open(filename, "rb") as file:
@@ -55,6 +55,68 @@ def encrypt(filename, key):
         file.write(encrypted_data)
 ```
 
+## Error Handling
+'create_client_socket_mock' is called once to create a client socket:
+```python
+create_client_socket_mock = mock.MagicMock()
+```
+     
+'connect_to_server_mock' is called once with the returned value of create_client_socket_mock and the server address ('localhost', 12345) to establish a connection to the server:
+```python
+connect_to_server_mock = mock.MagicMock()
+```
+
+'write_key_mock' is called once to generate a key for the test:
+```python
+write_key_mock = mock.MagicMock()
+```
+
+'load_key_mock' is called once and returns the test key (b"test_key"):
+```python
+load_key_mock = mock.MagicMock(return_value=b"test_key")
+```
+    
+'encrypt_mock' is called once with any serialized data argument (mock.ANY) and the test key to encrypt the data:
+```python
+encrypt_mock = mock.MagicMock(return_value=b"encrypted_data")
+```
+
+'clientfinal.send_encrypted_data' method is mocked:
+```python
+clientfinal.encrypt = encrypt_mock
+```
+
+'receive_response_mock' is called once and returns the message "Connection successful":
+```python
+receive_response_mock = mock.MagicMock(return_value="Connection successful")
+```
+
+The assertions ensure that the above functions and methods are called with the expected arguments.
+
+'test_receive_and_decrypt_data' executes several tasks:
+   - Mocks the socket and other dependencies to simulate receiving encrypted data and decrypting it using a key;
+   - Sets up a mock socket (mock_socket), a mock key (mock_key), encrypted and decrypted data;
+   - Mocks the recv method of the socket to return the encrypted data;
+   - Mocks the Fernet class (from the serverfinal module) to return the decrypted data when decrypt is called;
+   - Calls the serverfinal.receive_and_decrypt_data function under test with the mocked objects;
+
+Assertions are made to check if:
+     - The result matches the expected decrypted data (self.assertEqual(result, decrypted_data)).
+     - The recv method of the socket is called once with the correct argument (mock_socket.recv.assert_called_once_with(1024)).
+     - The Fernet class is instantiated once with the mock key (mock_fernet.assert_called_once_with(mock_key)).
+     - The decrypt method of the Fernet instance is called once with the encrypted data (mock_fernet.return_value.decrypt.assert_called_once_with(encrypted_data)).
+
+'test_deserialize_data' executes the following tasks:
+   - Tests the serverfinal.deserialize_data function to ensure it correctly deserializes the given data and returns a dictionary;
+   - Sets up serialized data (serialized_data) and expected data (expected_data);
+   - Calls the serverfinal.deserialize_data function with the serialized data;
+   - Assertion is made to check if the result matches the expected data (self.assertEqual(result, expected_data)).
+
+Both tests include print statements to indicate when the specific test is being executed and when the test is successful.
+
+These tests ensure that the 'receive_and_decrypt_data' and 'deserialize_data' functions in the 'serverfinal' module are functioning as expected, with the necessary dependencies being invoked and returning the correct results.
+
+
 ## Contributing
 Group C end of module assignment
 Pull request accepted

commit f041324425a8621eab11c774f51cec9038872db7
Author: Olesia Shtern <olesya0789@gmail.com>
Date:   Sat Oct 7 10:40:22 2023 +0300

    updated indentation

diff --git a/unit_tests_client.py b/unit_tests_client.py
index 120b656..8a9d8af 100644
--- a/unit_tests_client.py
+++ b/unit_tests_client.py
@@ -70,7 +70,6 @@ class TestClient(unittest.TestCase):
         print("  - All mocked functions were called with the expected arguments.")
         print("  - Test completed successfully.")
 
-
 # functions - test_write_key, test_load_key, test_encrypt and test_decrypt no longer required. 
 # above functions will be called by mocking the functions and methods. 
 #mock assesertions will confirm test pass or fail. 

commit 66439cd1862fb07b8371255729500526654d2c8a
Author: Olesia Shtern <olesya0789@gmail.com>
Date:   Sat Oct 7 09:25:36 2023 +0300

    deleted unused code

diff --git a/unit_tests_client.py b/unit_tests_client.py
index 04718ad..120b656 100644
--- a/unit_tests_client.py
+++ b/unit_tests_client.py
@@ -75,66 +75,5 @@ class TestClient(unittest.TestCase):
 # above functions will be called by mocking the functions and methods. 
 #mock assesertions will confirm test pass or fail. 
 
-
-    #def test_write_key(self):
-        # Create a key file for testing
-        #with open("key.key", "wb") as key_file:
-          # key_file.write(b"test_key")
-
-        # Call the function that will generate a key and save it to a file
-       # write_key()
-
-        # Check whether the key file was created
-        #self.assertTrue(os.path.exists("key.key"))
-
-        # Check whether the key file is not empty and saved to a file
-        #self.assertTrue(os.path.getsize("key.key") > 0)
-
-        # Clean up the key file after the test
-       # os.remove("key.key")
-
-    #def test_load_key(self):
-        # Call the function
-        #key = load_key()
-
-        # Check whether the correct key was loaded
-        #expected_key = b"test_key"
-       # self.assertEqual(expected_key, key)
-
-        # Remove the key file after the test
-       # os.remove("key.key")
-
-    #def test_encrypt(self):
-        # Generate a test key
-       # test_key = Fernet.generate_key()
-
-        # Call the function
-       # encrypt("test_file.txt", test_key)
-
-        # Read the encrypted file
-       # with open("test_file.txt", "rb") as encrypted_file:
-            #encrypted_data = encrypted_file.read()
-
-        # Check if the file data is encrypted
-        #self.assertNotEqual(encrypted_data, b"Test data")
-
-    #def test_decrypt(self):
-        # Generate a test key
-        #test_key = Fernet.generate_key()
-
-        # Encrypt the test file
-        #encrypt("test_file.txt", test_key)
-
-        # Call the function
-        #decrypt("test_file.txt", test_key)
-
-        # Read the decrypted file
-        #with open("test_file.txt", "rb") as decrypted_file:
-            #decrypted_data = decrypted_file.read()
-
-        # Check if the file data is decrypted correctly
-        #self.assertEqual(decrypted_data, b"Test data")
-
-
 if __name__ == '__main__':
     unittest.main()

commit 9080a115cbc9d3236e0556580f48333c0a96bcbd
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Fri Oct 6 03:17:10 2023 +0100

    add low level details of how the script works with screenshots

diff --git a/Group C - Client Server Network Report.docx b/Group C - Client Server Network Report.docx
index 1c654c0..8c11bb9 100644
--- a/Group C - Client Server Network Report.docx	
+++ b/Group C - Client Server Network Report.docx	
@@ -101,7 +101,7 @@ APPENDICES	8
 
 Introduction
 
-The objective of this project is create a Client Server Network which once established is capable of facilitating the transmission of encrypted and serialised files. Also the server must have the seamless mechanism for decrypting and processing these files on the server side.    
+The objective of this project is creating a Client Server Network which once established can facilitate the transmission of encrypted and serialised files. Also, the server must have the seamless mechanism for decrypting and processing these files on the server side.    
 SCOPE OF PROJECT
 The code and software architecture report will explain how Group C developed our Client Server Network and deployed it on to the local network. 
 The project needs to have three key functions:
@@ -110,10 +110,16 @@ The project needs to have three key functions:
  Decrypting the data and demonstrating the information in required format by printing it. 
 Purpose of Report                                                                 
 This report and the related code created by Group C will demonstrate the following:
- Understanding of network communication, creation and manipulation of data structures, 
+ Understanding of network communication, creation, and manipulation of data structures
  Transmission of data between client and server, 
  Implementation of advanced features such as data serialisation in various formats and encryption of text files.
-We decided to break this project into four roles of Project Manager, Architect, Developer and Testerto reflect how this project would be managed as a real time project in industry. This will enable Group C to acquire the essential skills for designing and managing networked systems in real-world scenarios whilst gaining an understanding of how data security works and the importance of privacy.via encryption
+   
+The Group decided to break this project into four roles of Project Manager, Architect, Developer and Tester to reflect how this project would be managed as a real time project in industry. This will enable Group C to acquire the essential skills for designing and managing networked systems in real-world scenarios whilst gaining an understanding of how data security works and the importance of data privacy using encryption.
+
+Team has a public repository on GitHub which was used throughout the project for collaboration and version control. Team's public repository can be found using this link  -  
+https://github.com/callmehawa/Client_Server_Network_GroupC. [HYPERLINK: https://github.com/callmehawa/Client_Server_Network_GroupC.git]git
+
+Team Member - 
 
 
 Solution Overview
@@ -150,30 +156,94 @@ Solution Design (Client)
 
                                        
                                        
-Key components within the Client design
 
-    Serialisation: Serialise the data into a structured format to maintain data integrity and interoperability. 
-    Key Management: The key management component is responsible for generating and managing encryption keys.
-    Encryption: The encryption component is responsible for encrypting and decrypting data using the encryption keys provided by the key management component.
- Client: The client is responsible for sending encrypted data
+
+Python script clientfinal.py is written to serialise a dictionary, encrypt it and send it over to a server using socket programming. Fernet library is used to encrypt the data, pickle module for serialising and socket library to send and receive data over the network. These are imported as below  - 
+
+                                        
+
+The script is organised into functions, making it readable, maintainable, available for reuse and isolated for effective unit testing.
+
+
+The script includes comments and docstrings describing each function's purpose and what it does.
+
+
+
+
+
+
+Error handling for every function is built into the code using the try-except block.
+
+
+
+The script operates as follows:
+ A client socket is established by utilising the create_client_socket() function.
+ Connects to the server using the connect_to_server() function.
+ New encryption key is generated and written to a file using the write_key() function.
+ Encryption key is loaded from the file using the load_key() function.
+ The pickle module converts a dictionary into binary format for easy storage and transfer.
+ The data is serialised and then encrypted using the encrypt() function.
+ The data is encrypted and sent to the server using the send_encrypted_data() function.
+ The function receive_response() is utilised to obtain a response from the server.
+ After receiving a response, the system decodes it and displays it on the console as a response from the server.
+ Before exiting, the script ensures that the client socket is closed.
+
+Error handling within the script:
+
+ If the script cannot create the client socket, it will display an error message and terminate.
+ If the client socket fails to connect to the server, an error message is printed, and the socket is closed.
+ If the script fails to generate or write the encryption key to the file, an error message is printed, and the script exits.
+ If the encryption key cannot be loaded from the file, an error message is printed, and the script exits.
+ If the serialised data cannot be encrypted, the script prints an error message and exits.
+ The script prints an error message if the encrypted data cannot be sent to the server.
+ If the server cannot receive a response, the script prints an error message.
+ If any other error occurs, the script prints an error message and exits.
+
+
+
+
+   
 Solution Design (Server) 
 
 
 
 
-Key components within the Server design 
- Server: The server opens a socket to listen for incoming client connections. Once a connection is established, the server receives the file from the client. The server receives the file from the client. using a TCP Protocol.
- Decryption: The server decrypts the file using the same key used to encrypt it. This will be done via the Fernet Key generated by the client. This key will be supplied along with the file. 
- De-serialisation: The server de-serialises the data in the file to a json format.
- Print: The server prints the contents of the dictionary.
+Python script serverfinal.py is written to receive encrypted serialised data from the client. It uses the socket module to create a server socket and accept incoming connections. It then uses the cryptography.fernet module to decrypt the data using a Fernet key. 
+
+Finally, it uses the pickle module to deserialise the data and save it to a file. The script includes comments and docstrings describing each function's purpose and what it does. 
+
+The script operates as follows:
+ create_server_socket() creates a TCP server socket and binds it to the specified address and port.
    
-Error Handling
-Design Decisions
+ accept_connection() function accepts an incoming connection on the server socket and returns the client socket.
+   
+ load_fernet_key() this function loads the Fernet encryption key from the specified file.
+   
+ receive_and_decrypt_data() this function receives encrypted data from the client socket, decrypts it using the Fernet key, and returns the decrypted data.
+   
+ deserialize_data() this function deserialises the decrypted data using the pickle library.
+   
+ save_decrypted_data_to_file() this function saves the deserialised data to the specified file using the pickle library.
+   
+ send_response() this function sends the specified response back to the client socket.
+   
+ server_connection() this function is the main entry point for the server. It creates a server socket, accepts a connection from a client, loads the Fernet key, receives and decrypts the data from the client, deserialises the data, saves it to a file, and then sends a response back to the client.
+   
+
+ Once a successful connection is established `try' block will be executed which has the main logic of the server and will call functions to create server socket, load fernet key, de-serialise and decrypt data. Once complete it will as user or an output option of `print' or `save'.
+   
+ 
+Error handling for every function is built into the code using the try-except block.
+
 
-Serialisation: Pickle module is used to serialise the dictionary into JSON format for the following reasons  -  
- JSON is a text-based format that is easy to read and write.
- It is a language-agnostic format and interoperability between systems written in different languages.
- It is a lightweight format with minimal overhead.
+
+Error handling within the script:
+ Socket errors will result in error messages and exceptions being raised.
+ If the key file is not found, an error is printed, and an exception is raised.
+ If the encrypted data cannot be decrypted, the code raises an exception and prints an error.
+ If the de-serialised data cannot be saved to a file, the code raises an exception and prints an error message.
+ If an error occurs while sending the response to the client, the code prints an error message and raises an exception.
+Design Decisions
 
 Encryption: Fernet Cryptographic protocol will be used as our encryption tool of choice for the following reasons - 
  Fernet uses symmetric key cryptography, which is simple and easy to use.  
@@ -181,8 +251,53 @@ Encryption: Fernet Cryptographic protocol will be used as our encryption tool of
 
 
 Unit Testing
-Serialization Unit Testing
-Encryption Unit Testing
+ Unit testing is essential for maintaining code quality, reducing bugs, and supporting code changes. We have used GitHub Actions, a CI/CD platform, to run unit tests every time code is committed to a GitHub repository. 
+ 
+ This is done by creating an action flow that defines the steps that should be taken when code is pushed to a branch. In this instance, the workflow will run either unit_tests_client.py or unit_tests_server.py every time code is pushed or pulled from any branch within the repository. Running unit tests every time code is committed using GitHub Actions, helps in early detection of bugs and improves quality.
+Server Unit Testing
+This unit tests are used to test the function within the server script called serverfinal.py. The tests status by creating a key file for testing and then mocks functions of serverfinal.py:
+
+ receive_and_decrypt_data(), which receives encrypted data from a socket and decrypts it using a key.
+ deserialize_data(), which deserializes a given data and returns a dictionary.
+   
+The receive_and_decrypt_data() function receives encrypted data over a socket and decrypts it using a secret key. 
+
+
+
+The deserialize_data() function deserialises a given byte stream into a Python dictionary.
+
+
+
+Unittest module provides the basic framework for writing unit tests and unittest.mock module provides methods for mocking objects. Serverfinal.py is imported to enable the script to call functions defined within the client script. 
+
+
+
+The unit tests use the unittest.TestCase class to create test cases. Each test case starts with a setUp() method, which generates a test_key to use to decrypt the file and ends with a tearDown() method, which clears the key file after testing. 
+
+
+The test cases for the receive_and_decrypt_data() function mock the socket to simulate receiving encrypted data and using the key to decrypt the data. The test case also runs function to return the decrypted data and returns as dictionary.  
+
+
+Client Unit Testing
+This unit tests are used to test the function within the server script called clientfinal.py. The test uses the unittest and mock modules to test the functionality of the client (clientfinal.py) module without connecting to a server and send and receive data.
+
+The test case starts by creating a key file for testing. It then mocks the following functions and methods in the clientfinal module:
+ create_client_socket
+ connect_to_server
+ write_key
+ load_key
+ encrypt
+ receive_response
+   
+
+After the main function has been called, assertions are used to verify that the functions and methods in the clientfinal module are called with the expected arguments. This validates that the code is running as intended. 
+
+
+
+The test case then prints a custom message of the outcome of the test.
+
+
+
 
 
 
@@ -193,18 +308,10 @@ REFERENCES
 
 
 APPENDICES 
-
-Group Artifacts
-1
-GitHub Repository
-2
-Client Server Network Project report
-3
-Requirement.txt
-4
-Readme.md
-5
-Screenshot of Github repo
-6
-Screenshot of Logs
-
+	
+ GitHub Repository - 
+ Client Server Network Project report
+ Requirement.txt
+ Readme.md
+ Screenshot of Github repo
+ Screenshot of Logs
diff --git a/__pycache__/clientfinal.cpython-311.pyc b/__pycache__/clientfinal.cpython-311.pyc
deleted file mode 100644
index 128867c..0000000
Binary files a/__pycache__/clientfinal.cpython-311.pyc and /dev/null differ
diff --git a/dict.pickle b/dict.pickle
deleted file mode 100644
index 1da61cf..0000000
Binary files a/dict.pickle and /dev/null differ

commit 4244816e5e81a0fc59b8be99728e35485c87fb62
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Fri Oct 6 03:14:49 2023 +0100

    added some comments to explain the code

diff --git a/clientfinal.py b/clientfinal.py
index 535a342..1d792b3 100644
--- a/clientfinal.py
+++ b/clientfinal.py
@@ -46,6 +46,14 @@ def encrypt(data, key):
         return None
 
 def send_encrypted_data(client_socket, encrypted_data):
+    """
+    Sends the given encrypted data to the client socket.
+        Args:
+            client_socket: A TCP client socket object.
+            encrypted_data: The encrypted data to send.
+        Returns:
+            `None` if there was an error sending the data.
+    """
     try:
         client_socket.send(encrypted_data)
     except socket.error as e:

commit 426f5e09cc71be1b157fc9ac3b5a2b543d501d86
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Fri Oct 6 03:14:07 2023 +0100

    amended to include input() function. This will ask for an output option (save or print) from the user

diff --git a/serverfinal.py b/serverfinal.py
index c73d351..1ec0db5 100644
--- a/serverfinal.py
+++ b/serverfinal.py
@@ -61,7 +61,7 @@ def save_decrypted_data_to_file(data, file_path):
     try:
         with open(file_path, 'wb') as file:
             pickle.dump(data, file)
-        print("Data saved to file:", file_path)
+        #print("Data saved to file:", file_path)
     except Exception as e:
         print("Error saving data to file:", e)
         raise
@@ -91,6 +91,20 @@ def server_connection(
         deserialized_data = deserialize_data(decrypted_data)
         save_decrypted_data_to_file(deserialized_data, decrypted_data_file_path)
 
+        #use of input() to prompt use to either save to print the file
+
+        output_option = input("Enter 'print' to print the decrypted data or 'save' to save it to a file: ")
+
+        if output_option == 'print':
+            print("Decrypted data:", deserialized_data)
+        elif output_option == 'save':
+            save_decrypted_data_to_file(deserialized_data, decrypted_data_file_path)
+            print("Data saved to file:", decrypted_data_file_path)
+            return
+        else:
+            print("Invalid output option:", output_option)
+
+       
         response = "Received and decrypted data successfully."
         send_response(client_socket, response)
     except Exception as e:

commit 0bab3ee949d53f4656b16c7a1f93b19cffd44467
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Fri Oct 6 03:12:58 2023 +0100

    added doc string and in code comments

diff --git a/unit_tests_server.py b/unit_tests_server.py
index 891a0fb..bb10d25 100644
--- a/unit_tests_server.py
+++ b/unit_tests_server.py
@@ -1,38 +1,56 @@
+"""
+Unit tests for actions within server script
+
+"""
+
 import unittest
 from unittest.mock import Mock, patch
 import os
 import serverfinal
 
 class ServerFinalTests(unittest.TestCase):
+    """
+    Test cases for the server script
+    """
 
     def setUp(self):
-        # Create a key file for testing
+        """
+        Create a key file for testing
+        """
         with open("test_key.key", "wb") as key_file:
             key_file.write(b"test_key")
 
     def tearDown(self):
-        # Remove the key file if it exists after each test
+        """
+        clear key file after testing
+        """
         os.remove("test_key.key")
 
     def test_receive_and_decrypt_data(self):
+        """
+        This test mocks the socket and other dependencies to simulate receiving encrypted data and
+        using key to decrypt the data and return it. 
+        """
+
         print("Testing receive_and_decrypt_data function...")
-        # Mock the socket and other dependencies
+
+        # Mock the socket and dependencies
         mock_socket = Mock()
         mock_key = b'secret_key'
-        encrypted_data = b'EncryptedData'
-        decrypted_data = b'DecryptedData'
+        encrypted_data = b'EncryptedData' # encrypted data in bytes
+        decrypted_data = b'DecryptedData' # decrypted data in bytes
 
-        # Mock the recv method of the socket to return the encrypted data
+        # Mock the listening method of the server to return the encrypted data
         mock_socket.recv.return_value = encrypted_data
 
-        # Mock the serverfinal.Fernet.decrypt method
+        # Mock the Fernet class to decrypt data received
         with patch('serverfinal.Fernet') as mock_fernet:
             mock_fernet.return_value.decrypt.return_value = decrypted_data
 
             # Call the function to be tested
             result = serverfinal.receive_and_decrypt_data(mock_socket, mock_key)
 
-            # Assertions
+            # Assertions to check if condition are met or true. 
             self.assertEqual(result, decrypted_data)
             mock_socket.recv.assert_called_once_with(1024)
             mock_fernet.assert_called_once_with(mock_key)
@@ -41,7 +59,12 @@ class ServerFinalTests(unittest.TestCase):
         print("receive_and_decrypt_data test successful!")
 
     def test_deserialize_data(self):
+        """
+        Test the deserialize_data function to check of function correctly deserializes the given data and returns a dictionary.
+
+        """
         print("Testing deserialize_data function...")
+        
         # Test the deserialize_data function
         serialized_data = b'\x80\x03}q\x00(X\x03\x00\x00\x00keyq\x01X\x05\x00\x00\x00valueq\x02u.'
         expected_data = {'key': 'value'}

commit c72b75249e0116e8ae71dd5e4293043e64c953d7
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Oct 5 22:24:14 2023 +0100

    removed unwanted import  encryption from the script

diff --git a/__pycache__/clientfinal.cpython-311.pyc b/__pycache__/clientfinal.cpython-311.pyc
new file mode 100644
index 0000000..128867c
Binary files /dev/null and b/__pycache__/clientfinal.cpython-311.pyc differ
diff --git a/dict.pickle b/dict.pickle
new file mode 100644
index 0000000..1da61cf
Binary files /dev/null and b/dict.pickle differ
diff --git a/unit_tests_client.py b/unit_tests_client.py
index a34fb3a..04718ad 100644
--- a/unit_tests_client.py
+++ b/unit_tests_client.py
@@ -3,9 +3,9 @@ from unittest import mock
 import clientfinal
 import os
 from cryptography.fernet import Fernet
-from encryption import write_key, decrypt
-from encryption import load_key
-from encryption import encrypt
+#from encryption import write_key, decrypt
+#from encryption import load_key
+#from encryption import encrypt
 
 
 class TestClient(unittest.TestCase):

commit 55f6385bf5dd7a844be665f60443ab916718d866
Merge: fefc875 8726d15
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Oct 5 22:19:45 2023 +0100

    Merge branch 'main' of https://github.com/callmehawa/Client_Server_Network_GroupC

commit fefc8754388b1b912bc217cc5b2fea744adb9e18
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Oct 5 22:19:06 2023 +0100

    cleaning up the repository as agreed with the team. All redundant files have been deleted. These files were created to enable individual team member to contribute each section of the code but they have now been merged with the main script

diff --git a/New File b/New File
deleted file mode 100644
index e69de29..0000000
diff --git a/__pycache__/clientfinal.cpython-311.pyc b/__pycache__/clientfinal.cpython-311.pyc
deleted file mode 100644
index 05dc130..0000000
Binary files a/__pycache__/clientfinal.cpython-311.pyc and /dev/null differ
diff --git a/__pycache__/cryptography.cpython-311.pyc b/__pycache__/cryptography.cpython-311.pyc
deleted file mode 100644
index 5478ea5..0000000
Binary files a/__pycache__/cryptography.cpython-311.pyc and /dev/null differ
diff --git a/__pycache__/encryption.cpython-311.pyc b/__pycache__/encryption.cpython-311.pyc
deleted file mode 100644
index 1512564..0000000
Binary files a/__pycache__/encryption.cpython-311.pyc and /dev/null differ
diff --git a/__pycache__/serverfinal.cpython-311.pyc b/__pycache__/serverfinal.cpython-311.pyc
deleted file mode 100644
index a6d31a0..0000000
Binary files a/__pycache__/serverfinal.cpython-311.pyc and /dev/null differ
diff --git a/__pycache__/unit_tests_encryption.cpython-311.pyc b/__pycache__/unit_tests_encryption.cpython-311.pyc
deleted file mode 100644
index 23abf82..0000000
Binary files a/__pycache__/unit_tests_encryption.cpython-311.pyc and /dev/null differ
diff --git a/client.py b/client.py
deleted file mode 100644
index b3f4a5d..0000000
--- a/client.py
+++ /dev/null
@@ -1,28 +0,0 @@
-import socket 
-
-#local server details
-
-server_address=("127.0.0.1",12345)
-
-client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-
-client_socket.connect(server_address)
-
-# file to send
-file_name = "dicitionary.py"  #json file script
-
-try:
-    # Open file in read me file
-    with open(file_name, "rb") as file:
-        
-        chunk = file.read(1024)
-        while chunk:     #chunk is parts of the file
-            # Send the chunk to the socketserver
-            client_socket.send(chunk)
-            chunk = file.read(1024)
-    print(f"Python script '{file_name}' sent successfully.")
-except FileNotFoundError:
-    print(f"Python script '{file_name}' not found.")
-
-# Close the socket
-client_socket.close()
\ No newline at end of file
diff --git a/client_file b/client_file
deleted file mode 100644
index ad16003..0000000
--- a/client_file
+++ /dev/null
@@ -1,92 +0,0 @@
-import socket
-import pickle
-from cryptography.fernet import Fernet
-
-# Create a socket object
-client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-
-# Server address and port
-server_address = ('localhost', 12345)
-
-# Connect to the server
-client_socket.connect(server_address)
-
-def write_key():
-    """
-    Generate a cryptographic key and save it to a file.
-
-    This function generates a Fernet key and saves it to a file named 'key.key' in binary format.
-    Generating a key and saving it into a file
-    """
-    key = Fernet.generate_key()
-    with open("key.key", "wb") as key_file:
-        key_file.write(key)
-
-def load_key():
-    """
-    Load the cryptographic key from the 'key.key' file.
-
-    Returns:
-        bytes: The Fernet key loaded from the 'key.key' file.
-    Loading the key from the current directory named `key.key`
-    """
-    return open("key.key", "rb").read()
-
-# Generate and write a new key
-write_key()
-
-# Load the previously generated key
-key = load_key()
-#print(f"Fernet Key: {key.hex()}")
-
-# Call the print_key function to print the key
-load_key()
-#write_key()
-
-try:
-    # Add a new dictionary
-    dictionary = {"name": "Pawan", "age": 40, "city": "Preston"}
-
-    # Create a file to serialize into pickle
-    with open('dict.pickle', 'wb') as file:
-        pickle.dump(dictionary, file)
-
-    # Read the serialized data from the file
-    with open('dict.pickle', 'rb') as file:
-        serialised_data = file.read()
-
-    def encrypt(data, key):
-        """
-        Encrypt data using a Fernet key.
-
-        Args:
-            data (bytes): The data to be encrypted.
-            key (bytes): The Fernet key used for encryption.
-
-        Returns:
-            bytes: The encrypted data.
-        """
-        f = Fernet(key)
-        encrypted_data = f.encrypt(data)
-        return encrypted_data
-
-    # Encrypt the serialized data
-    encrypted_data = encrypt(serialised_data, key)
-
-    # Send encrypted data to the server
-    client_socket.send(encrypted_data)
-
-    # Receive a response from the server
-    response = client_socket.recv(1024)
-    print(f"Message from server: {response.decode('utf-8')}")
-
-except Exception as e:
-    """
-    try-except block to handle excpetion and print error message
-    """
-    print(f"An error occurred: {e}")
-    sys.exit(1)
-
-finally:
-    # Clean up the connection
-    client_socket.close()
diff --git a/decrypted_dict.pickle b/decrypted_dict.pickle
deleted file mode 100644
index a019c75..0000000
Binary files a/decrypted_dict.pickle and /dev/null differ
diff --git a/deserialization.py b/deserialization.py
deleted file mode 100644
index 1d7eda8..0000000
--- a/deserialization.py
+++ /dev/null
@@ -1,12 +0,0 @@
-'''
-The code uses pickle module to deserialize dictionary from file
-'''
-# importing pickle module
-import pickle
-
-# deserialize data from file
-with open('dict.pickle', 'rb') as file:
-    data = pickle.load(file)
-
-# prints deserialized data
-print(data) 
\ No newline at end of file
diff --git a/dict.json b/dict.json
deleted file mode 100644
index 1da61cf..0000000
Binary files a/dict.json and /dev/null differ
diff --git a/dict.pickle b/dict.pickle
deleted file mode 100644
index 1da61cf..0000000
Binary files a/dict.pickle and /dev/null differ
diff --git a/dictionary.py b/dictionary.py
deleted file mode 100644
index 50ed44d..0000000
--- a/dictionary.py
+++ /dev/null
@@ -1,13 +0,0 @@
-'''
-The code uses pickle module to serialize dictionary and
-save it to file in binary format
-'''
-# importing pickle module
-import pickle
-
-# Create a dictionary with key-value pairs
-dictionary = {"name": "Pawan", "age": 40, "city": "Preston"}
-
-# creates new file to serialize into pickle
-with open('dict.pickle', 'wb') as file:
-    pickle.dump(dictionary, file)
diff --git a/encrypted_data.json b/encrypted_data.json
deleted file mode 100644
index d89d544..0000000
--- a/encrypted_data.json
+++ /dev/null
@@ -1 +0,0 @@
-gAAAAABlFe3LbXD8lwFg4-lE_fBBtFBXsVvxwQG9wg8qtnv1Rf5kHVwZ6fUqaXX9HQAaD4FRYw2QZv_VSQ_o7BjxCdeyfIAqW7jSno5jYeeQad2arspyaC2OKzQ6jZhCXN6u8OtVbH9t
\ No newline at end of file
diff --git a/encryption.py b/encryption.py
deleted file mode 100644
index e2569d4..0000000
--- a/encryption.py
+++ /dev/null
@@ -1,67 +0,0 @@
-from cryptography.fernet import Fernet
-
-
-def write_key():
-    """
-    Generating a key and saving it into a file
-    """
-    key = Fernet.generate_key()
-    with open("key.key", "wb") as key_file:
-        key_file.write(key)
-
-
-def load_key():
-    """
-    Loading the key from the current directory named `key.key`
-    """
-    return open("key.key", "rb").read()
-
-
-# generating and writing a new key
-write_key()
-
-# loading the previously generated key
-key = load_key()
-
-message = "some secret message".encode()
-
-# initializing the Fernet class
-f = Fernet(key)
-
-# encrypting the message
-encrypted = f.encrypt(message)
-
-# printing how it looks
-print(encrypted)
-
-
-def encrypt(filename, key):
-    """
-    Given a filename (str) and key (bytes), it encrypts the file and write it
-    """
-    f = Fernet(key)
-    with open(filename, "rb") as file:
-        # read all file data
-        file_data = file.read()
-
-    # encrypt data
-    encrypted_data = f.encrypt(file_data)
-
-    # write the encrypted file
-    with open(filename, "wb") as file:
-        file.write(encrypted_data)
-
-
-def decrypt(filename, key):
-    """
-    Given a filename (str) and key (bytes), it decrypts the file and write it
-    """
-    f = Fernet(key)
-    with open(filename, "rb") as file:
-        # read the encrypted data
-        encrypted_data = file.read()
-    # decrypt data
-    decrypted_data = f.decrypt(encrypted_data)
-    # write the original file
-    with open(filename, "wb") as file:
-        file.write(decrypted_data)
diff --git a/key.key b/key.key
deleted file mode 100644
index 4a72c94..0000000
--- a/key.key
+++ /dev/null
@@ -1 +0,0 @@
-vpl9M3pL3XvcCeWbgf9T5NnYPQNa9L7IREE7M5jh7Kw=
\ No newline at end of file
diff --git a/server.py b/server.py
deleted file mode 100644
index b3f4a5d..0000000
--- a/server.py
+++ /dev/null
@@ -1,28 +0,0 @@
-import socket 
-
-#local server details
-
-server_address=("127.0.0.1",12345)
-
-client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-
-client_socket.connect(server_address)
-
-# file to send
-file_name = "dicitionary.py"  #json file script
-
-try:
-    # Open file in read me file
-    with open(file_name, "rb") as file:
-        
-        chunk = file.read(1024)
-        while chunk:     #chunk is parts of the file
-            # Send the chunk to the socketserver
-            client_socket.send(chunk)
-            chunk = file.read(1024)
-    print(f"Python script '{file_name}' sent successfully.")
-except FileNotFoundError:
-    print(f"Python script '{file_name}' not found.")
-
-# Close the socket
-client_socket.close()
\ No newline at end of file

commit 8726d1520e7c91e106e837211f5751339f1fc081
Author: ThatalP <142354418+callmehawa@users.noreply.github.com>
Date:   Thu Oct 5 19:35:42 2023 +0100

    Update requirement.txt
    
    Added cryptography installation as a requirement.

diff --git a/requirement.txt b/requirement.txt
index 68549c6..32448ac 100644
--- a/requirement.txt
+++ b/requirement.txt
@@ -1 +1,3 @@
-# Only list libraries that are installed part of the Project, no need for a import statement.
+Install Cryptography
+
+pip install cryptography

commit cd033d3eb2cafb4c4a0ca028417fb3b2c3506b80
Merge: 21b30aa ce580bc
Author: ThatalP <142354418+callmehawa@users.noreply.github.com>
Date:   Thu Oct 5 19:23:07 2023 +0100

    Merge pull request #7 from callmehawa/readme_edit2
    
    Readme edit2

commit ce580bc48754dcac5ed9f637de36d8efb75a957d
Author: Olesya <40202074+oshtern@users.noreply.github.com>
Date:   Thu Oct 5 20:36:21 2023 +0300

    Update README.md
    
    Added info in README file

diff --git a/README.md b/README.md
index e59a7a9..2d309ed 100644
--- a/README.md
+++ b/README.md
@@ -3,13 +3,57 @@
 This is a Project to create a simple Client Server network. Create a dictionary, popluate it, serialise and encrypt it and send it to the server. 
 The server will receive the file, decrypt, deserialise it and print the file
 
-## Install
 
-cyrptography
+## Creating a file
 
-## Usage
+First, we need to initialize the file we are going to work with:
+```
+dictionary = {"name": "Pawan", "age": 40, "city": "Preston"}
+with open('dict.pickle', 'wb') as file:
+    pickle.dump(dictionary, file)
+```
+## File encryption
 
-Demonstration of simple client server network and how a string can be serialised, encrypted and sent. 
+We can encrypt the file by generating a key first and saving it:
+```
+def write_key():
+    key = Fernet.generate_key()
+    with open("key.key", "wb") as key_file:
+        key_file.write(key)
+```
+After this, we need to load this key:
+```
+def load_key():
+    return open("key.key", "rb").read()
+```
+Generating a new key:
+```
+write_key()
+key = load_key()
+message = "some secret message".encode()
+```
+Here we are encrypting the message and printing it out:
+```
+f = Fernet(key)
+encrypted = f.encrypt(message)
+print(encrypted)
+```
+
+The process of encrypting the file, reading the file data and writing the encrypted file:
+```
+def encrypt(filename, key):
+    f = Fernet(key)
+    with open(filename, "rb") as file:
+
+        file_data = file.read()
+
+
+    encrypted_data = f.encrypt(file_data)
+
+
+    with open(filename, "wb") as file:
+        file.write(encrypted_data)
+```
 
 ## Contributing
 Group C end of module assignment

commit ccf2b267c226213933657929d762887b776f0f0c
Author: Olesia Shtern <olesya0789@gmail.com>
Date:   Thu Oct 5 20:09:00 2023 +0300

    uncommented imports

diff --git a/unit_tests_client.py b/unit_tests_client.py
index 56b238e..a34fb3a 100644
--- a/unit_tests_client.py
+++ b/unit_tests_client.py
@@ -2,10 +2,10 @@ import unittest
 from unittest import mock
 import clientfinal
 import os
-#from cryptography.fernet import Fernet
-#from encryption import write_key, decrypt
-#from encryption import load_key
-#from encryption import encrypt
+from cryptography.fernet import Fernet
+from encryption import write_key, decrypt
+from encryption import load_key
+from encryption import encrypt
 
 
 class TestClient(unittest.TestCase):

commit 21b30aa0f87804d4140e92c7f0daec337cf20174
Merge: 3cb07ae 4f6d283
Author: nicolasKappa <125310666+nicolasKappa@users.noreply.github.com>
Date:   Thu Oct 5 19:36:17 2023 +0400

    Merge pull request #6 from callmehawa/unittest
    
    Unittest

commit 4f6d283ab42ef72b9b221d18d4b35504aea586c8
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Oct 5 16:09:51 2023 +0100

    added specific exceptional handling for each function using try-except

diff --git a/clientfinal.py b/clientfinal.py
index 2ca36a1..535a342 100644
--- a/clientfinal.py
+++ b/clientfinal.py
@@ -1,153 +1,103 @@
 import socket
 import pickle
 from cryptography.fernet import Fernet
-import sys
 
 def create_client_socket():
-    """Create and return a socket object for the client. 
-        Created fucntion for socket to enable unit testing using magic mock
-    """
-    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-    return client_socket
+    try:
+        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        return client_socket
+    except socket.error as e:
+        print(f"Socket creation error: {e}")
+        return None
 
 def connect_to_server(client_socket, server_address):
-    """
-    Connect to the server using the provided socket and server address.
-    Created fucntion for socket to enable unit testing using magic mock
-
-    """
-    client_socket.connect(server_address)
-
-   # server_address = ('localhost', 12345)
-   # client_socket.connect(server_address)
-
-def write_key():
-    """
-    Generate a cryptographic key and save it to a file.
-
-    This function generates a Fernet key and saves it to a file named 'key.key' in binary format.
-    Generating a key and saving it into a file
-    """
-    key = Fernet.generate_key()
-    with open("key.key", "wb") as key_file:
-        key_file.write(key)
+    try:
+        client_socket.connect(server_address)
+    except socket.error as e:
+        print(f"Connection error: {e}")
+        client_socket.close()
 
 def write_key(key_filename="key.key"):
-    """
-    Generate a cryptographic key and save it to a file.
-    This function generates a Fernet key and saves it to a specified file in binary format.
-    """
-    key = Fernet.generate_key()
-    with open(key_filename, "wb") as key_file:
-        key_file.write(key)
-   #return open("key.key", "rb").read()
-
-# Generate and write a new key
-#write_key()
-
-# Load the previously generated key and print it
-#key = load_key()
-#print(f"Fernet Key: {key.hex()}")
-#write_key()
+    try:
+        key = Fernet.generate_key()
+        with open(key_filename, "wb") as key_file:
+            key_file.write(key)
+    except Exception as e:
+        print(f"Key generation and writing error: {e}")
 
 def load_key(key_filename="key.key"):
-    """
-    Load the cryptographic key from the specified file.
-
-    Returns:
-        bytes: The Fernet key loaded from the file.
-    """
-    return open(key_filename, "rb").read()
+    try:
+        key = open(key_filename, "rb").read()
+        return key
+    except FileNotFoundError:
+        print(f"Key file '{key_filename}' not found.")
+        return None
+    except Exception as e:
+        print(f"Key loading error: {e}")
+        return None
 
 def encrypt(data, key):
-    """
-    Encrypt data using a Fernet key.
-
-    Args:
-        data (bytes): The data to be encrypted.
-        key (bytes): The Fernet key used for encryption.
-
-    Returns:
-            bytes: The encrypted data.
-    """
-    f = Fernet(key)
-    encrypted_data = f.encrypt(data)
-    return encrypted_data
+    try:
+        f = Fernet(key)
+        encrypted_data = f.encrypt(data)
+        return encrypted_data
+    except Exception as e:
+        print(f"Encryption error: {e}")
+        return None
 
 def send_encrypted_data(client_socket, encrypted_data):
-    """
-    Send encrypted data to the server using the provided socket.
-
-    Args:
-        client_socket (socket.socket): The client socket object.
-        encrypted_data (bytes): The encrypted data to send
-    """
-
-    client_socket.send(encrypted_data)
+    try:
+        client_socket.send(encrypted_data)
+    except socket.error as e:
+        print(f"Data sending error: {e}")
 
 def receive_response(client_socket, buffer_size=1024):
-    """
-    Receive a response from the server using the provided socket.
-
-    Args:
-        client_socket (socket.socket): The client socket object.
-        buffer_size (int): The size of the buffer for receiving data.
-
-    Returns:
-        str: The received response as a string.
-    """
-    response = client_socket.recv(buffer_size)
-    return response.decode('utf-8')
+    try:
+        response = client_socket.recv(buffer_size)
+        return response.decode('utf-8')
+    except socket.error as e:
+        print(f"Data receiving error: {e}")
+        return None
 
 def main():
     try:
         client_socket = create_client_socket()
+        if client_socket is None:
+            return
 
         server_address = ('localhost', 12345)
         connect_to_server(client_socket, server_address)
 
-        # Generate and write a new key
         write_key()
 
-        # Load the previously generated key
         key = load_key()
+        if key is None:
+            return
 
-    # Add a new dictionary
         dictionary = {"name": "Pawan", "age": 40, "city": "Preston"}
 
-    # Create a file to serialise into pickle
         with open('dict.pickle', 'wb') as file:
             pickle.dump(dictionary, file)
 
-    # Read the serialized data from the file
         with open('dict.pickle', 'rb') as file:
             serialised_data = file.read()
 
-    # Encrypt the serialized data
         encrypted_data = encrypt(serialised_data, key)
+        if encrypted_data is None:
+            return
 
-    # Send encrypted data to the server
-        client_socket.send(encrypted_data)
-    
-    # Send encrypted data to the server
         send_encrypted_data(client_socket, encrypted_data)
 
-    # Receive a response from the server
         response = receive_response(client_socket)
-        print(f"Message from server: {response}")
-        #response = client_socket.recv(1024)
-        #print(f"Message from server: {response.decode('utf-8')}")
+        if response is not None:
+            print(f"Message from server: {response}")
 
     except Exception as e:
-        """
-        try-except block to handle excpetion and print error message
-        """
         print(f"An error occurred: {e}")
-    #sys.exit(1)
 
     finally:
-    # Clean up the connection
-        client_socket.close()
-        
+        if client_socket is not None:
+            client_socket.close()
+
 if __name__ == '__main__':
-    main()
\ No newline at end of file
+    main()

commit 7b1da3647d4f2a4a42c46e59a3bd24d00fdea82d
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Oct 5 16:09:35 2023 +0100

    added specific exceptional handling for each function using try-except

diff --git a/serverfinal.py b/serverfinal.py
index 8ff0909..c73d351 100644
--- a/serverfinal.py
+++ b/serverfinal.py
@@ -3,52 +3,85 @@ import pickle
 from cryptography.fernet import Fernet
 
 def create_server_socket(address, port):
-    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-    server_socket.bind((address, port))
-    server_socket.listen(1)
-    print("Server is listening on {}:{}".format(address, port))
-    return server_socket
+    try:
+        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        server_socket.bind((address, port))
+        server_socket.listen(1)
+        print("Server is listening on {}:{}".format(address, port))
+        return server_socket
+    except socket.error as e:
+        print("Socket error:", e)
+        raise
 
 def accept_connection(server_socket):
-    client_socket, client_address = server_socket.accept()
-    print("Accepted connection from {}:{}".format(*client_address))
-    return client_socket
+    try:
+        client_socket, client_address = server_socket.accept()
+        print("Accepted connection from {}:{}".format(*client_address))
+        return client_socket
+    except socket.error as e:
+        print("Error accepting connection:", e)
+        raise
 
 def load_fernet_key(key_file_path):
-    with open(key_file_path, "rb") as key_file:
-        key = key_file.read()
-    print("Loaded key: ", key)
-    return key
+    try:
+        with open(key_file_path, "rb") as key_file:
+            key = key_file.read()
+        print("Loaded key: ", key)
+        return key
+    except FileNotFoundError as e:
+        print("Key file not found:", e)
+        raise
+    except Exception as e:
+        print("Error loading key:", e)
+        raise
 
 def receive_and_decrypt_data(client_socket, key):
-    encrypted_data = client_socket.recv(1024)
-    print("Received encrypted_data: ", encrypted_data)
+    try:
+        encrypted_data = client_socket.recv(1024)
+        print("Received encrypted_data: ", encrypted_data)
 
-    f = Fernet(key)
-    decrypted_data = f.decrypt(encrypted_data)
-    print("Decryption successful.")
-    return decrypted_data
+        f = Fernet(key)
+        decrypted_data = f.decrypt(encrypted_data)
+        print("Decryption successful.")
+        return decrypted_data
+    except Exception as e:
+        print("Decryption failed:", e)
+        raise
 
 def deserialize_data(data):
-    deserialized_data = pickle.loads(data)
-    print("Deserialized data:", deserialized_data)
-    return deserialized_data
+    try:
+        deserialized_data = pickle.loads(data)
+        print("Deserialized data:", deserialized_data)
+        return deserialized_data
+    except pickle.PickleError as e:
+        print("Error deserializing data:", e)
+        raise
 
 def save_decrypted_data_to_file(data, file_path):
-    with open(file_path, 'wb') as file:
-        pickle.dump(data, file)
-    print("Data saved to file:", file_path)
+    try:
+        with open(file_path, 'wb') as file:
+            pickle.dump(data, file)
+        print("Data saved to file:", file_path)
+    except Exception as e:
+        print("Error saving data to file:", e)
+        raise
 
 def send_response(client_socket, response):
-    client_socket.send(response.encode('utf-8'))
+    try:
+        client_socket.send(response.encode('utf-8'))
+    except socket.error as e:
+        print("Error sending response:", e)
+        raise
 
-#def server_logic(
 def server_connection(
     server_address='localhost',
     server_port=12345,
     key_file_path='key.key',
     decrypted_data_file_path='decrypted_dict.pickle'
 ):
+    server_socket = None
+    client_socket = None
+
     try:
         server_socket = create_server_socket(server_address, server_port)
         client_socket = accept_connection(server_socket)
@@ -61,10 +94,12 @@ def server_connection(
         response = "Received and decrypted data successfully."
         send_response(client_socket, response)
     except Exception as e:
-        print("Decryption failed:", e)
+        print("Server error:", e)
     finally:
-        client_socket.close()
-        server_socket.close()
+        if client_socket:
+            client_socket.close()
+        if server_socket:
+            server_socket.close()
 
 if __name__ == "__main__":
     server_connection()

commit e3ad484b702eb398cc36e89aa8514ddb0e5d6dcf
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Oct 5 15:46:50 2023 +0100

    test_deserialize_data function amended to accurately run the test

diff --git a/unit_tests_server.py b/unit_tests_server.py
index fdf6712..891a0fb 100644
--- a/unit_tests_server.py
+++ b/unit_tests_server.py
@@ -54,3 +54,4 @@ class ServerFinalTests(unittest.TestCase):
  
 if __name__ == '__main__':
     unittest.main()
+

commit 2e3338e1313bf611cdfc92b92579935361d83c41
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Oct 5 15:45:57 2023 +0100

    amended as unit test was unable to pull deserailse function to test

diff --git a/serverfinal.py b/serverfinal.py
index dcb8fe2..8ff0909 100644
--- a/serverfinal.py
+++ b/serverfinal.py
@@ -2,57 +2,39 @@ import socket
 import pickle
 from cryptography.fernet import Fernet
 
-
-def create_server_socket(address, port):    
-# Create a socket object
+def create_server_socket(address, port):
     server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-# Bind the socket to a specific address and port
-#server_address = ('localhost', 12345)
     server_socket.bind((address, port))
-# Listen for incoming connections
     server_socket.listen(1)
     print("Server is listening on {}:{}".format(address, port))
     return server_socket
 
 def accept_connection(server_socket):
-# Accept a connection
     client_socket, client_address = server_socket.accept()
     print("Accepted connection from {}:{}".format(*client_address))
     return client_socket
 
 def load_fernet_key(key_file_path):
-    # Load the Fernet key
-    with open("key.key", "rb") as key_file:
+    with open(key_file_path, "rb") as key_file:
         key = key_file.read()
     print("Loaded key: ", key)
     return key
 
 def receive_and_decrypt_data(client_socket, key):
-    # Receive data from the client
     encrypted_data = client_socket.recv(1024)
     print("Received encrypted_data: ", encrypted_data)
 
-    # Decrypt the data using the key
     f = Fernet(key)
     decrypted_data = f.decrypt(encrypted_data)
     print("Decryption successful.")
     return decrypted_data
 
 def deserialize_data(data):
-
-    # Print the decrypted data
-    #print("Decrypted data:", decrypted_data.decode('utf-8'))
-    #print("Decrypted data as bytes:", decrypted_data)
-
-    # Deserialize the decrypted data using pickle
     deserialized_data = pickle.loads(data)
-    # Print the deserialized data
     print("Deserialized data:", deserialized_data)
-    return deserialize_data
+    return deserialized_data
 
 def save_decrypted_data_to_file(data, file_path):
-    # Save the decrypted data to a file
-    #with open('decrypted_dict.pickle', 'wb') as file:
     with open(file_path, 'wb') as file:
         pickle.dump(data, file)
     print("Data saved to file:", file_path)
@@ -60,6 +42,7 @@ def save_decrypted_data_to_file(data, file_path):
 def send_response(client_socket, response):
     client_socket.send(response.encode('utf-8'))
 
+#def server_logic(
 def server_connection(
     server_address='localhost',
     server_port=12345,
@@ -75,18 +58,13 @@ def server_connection(
         deserialized_data = deserialize_data(decrypted_data)
         save_decrypted_data_to_file(deserialized_data, decrypted_data_file_path)
 
-   # Send a response back to the client
         response = "Received and decrypted data successfully."
         send_response(client_socket, response)
-        #client_socket.send(response.encode('utf-8'))
-
     except Exception as e:
         print("Decryption failed:", e)
-
     finally:
-    # Clean up the connection
         client_socket.close()
         server_socket.close()
 
 if __name__ == "__main__":
-    server_connection()
\ No newline at end of file
+    server_connection()

commit 3cb07aef01adf0018293323c4e3c3bfc81591eb6
Author: ThatalP <142354418+callmehawa@users.noreply.github.com>
Date:   Thu Oct 5 15:19:13 2023 +0100

    Update unit_test_server.yml
    
    renamed the test to unit_test_server

diff --git a/.github/workflows/unit_test_server.yml b/.github/workflows/unit_test_server.yml
index 32bf314..27d7b35 100644
--- a/.github/workflows/unit_test_server.yml
+++ b/.github/workflows/unit_test_server.yml
@@ -1,5 +1,5 @@
 # This workflow will run unit test to check server functions whenever code is pushed to main branch or pulled from it.
-name: unit_test_client
+name: unit_test_server
 
 on:
   push:

commit f8eaef028e8735bf2a84ae0b4e6482397cadeec6
Merge: cd158a8 f6b485f
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Oct 5 15:14:40 2023 +0100

    Merge branch 'main' of https://github.com/callmehawa/Client_Server_Network_GroupC

commit cd158a887d63e6ab771119721b801d665324c479
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Oct 5 15:13:23 2023 +0100

    commiting key

diff --git a/__pycache__/clientfinal.cpython-311.pyc b/__pycache__/clientfinal.cpython-311.pyc
new file mode 100644
index 0000000..05dc130
Binary files /dev/null and b/__pycache__/clientfinal.cpython-311.pyc differ
diff --git a/__pycache__/serverfinal.cpython-311.pyc b/__pycache__/serverfinal.cpython-311.pyc
new file mode 100644
index 0000000..a6d31a0
Binary files /dev/null and b/__pycache__/serverfinal.cpython-311.pyc differ
diff --git a/decrypted_dict.pickle b/decrypted_dict.pickle
new file mode 100644
index 0000000..a019c75
Binary files /dev/null and b/decrypted_dict.pickle differ
diff --git a/dict.pickle b/dict.pickle
new file mode 100644
index 0000000..1da61cf
Binary files /dev/null and b/dict.pickle differ
diff --git a/key.key b/key.key
new file mode 100644
index 0000000..4a72c94
--- /dev/null
+++ b/key.key
@@ -0,0 +1 @@
+vpl9M3pL3XvcCeWbgf9T5NnYPQNa9L7IREE7M5jh7Kw=
\ No newline at end of file

commit 92f1e888e9f91b40df4e22b4b393ac2e15ffa262
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Oct 5 15:07:22 2023 +0100

    Added a new unit test using mock module to test server.py

diff --git a/unit_tests_server.py b/unit_tests_server.py
new file mode 100644
index 0000000..fdf6712
--- /dev/null
+++ b/unit_tests_server.py
@@ -0,0 +1,56 @@
+import unittest
+from unittest.mock import Mock, patch
+import os
+import serverfinal
+
+class ServerFinalTests(unittest.TestCase):
+
+    def setUp(self):
+        # Create a key file for testing
+        with open("test_key.key", "wb") as key_file:
+            key_file.write(b"test_key")
+
+    def tearDown(self):
+        # Remove the key file if it exists after each test
+        os.remove("test_key.key")
+
+    def test_receive_and_decrypt_data(self):
+        print("Testing receive_and_decrypt_data function...")
+        # Mock the socket and other dependencies
+        mock_socket = Mock()
+        mock_key = b'secret_key'
+        encrypted_data = b'EncryptedData'
+        decrypted_data = b'DecryptedData'
+
+        # Mock the recv method of the socket to return the encrypted data
+        mock_socket.recv.return_value = encrypted_data
+
+        # Mock the serverfinal.Fernet.decrypt method
+        with patch('serverfinal.Fernet') as mock_fernet:
+            mock_fernet.return_value.decrypt.return_value = decrypted_data
+
+            # Call the function to be tested
+            result = serverfinal.receive_and_decrypt_data(mock_socket, mock_key)
+
+            # Assertions
+            self.assertEqual(result, decrypted_data)
+            mock_socket.recv.assert_called_once_with(1024)
+            mock_fernet.assert_called_once_with(mock_key)
+            mock_fernet.return_value.decrypt.assert_called_once_with(encrypted_data)
+        
+        print("receive_and_decrypt_data test successful!")
+
+    def test_deserialize_data(self):
+        print("Testing deserialize_data function...")
+        # Test the deserialize_data function
+        serialized_data = b'\x80\x03}q\x00(X\x03\x00\x00\x00keyq\x01X\x05\x00\x00\x00valueq\x02u.'
+        expected_data = {'key': 'value'}
+
+        result = serverfinal.deserialize_data(serialized_data)
+
+        self.assertEqual(result, expected_data)
+        print("deserialize_data test successful!")
+
+ 
+if __name__ == '__main__':
+    unittest.main()

commit 0481832bcade6f2472dd67bb4c8646dff118a865
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Oct 5 15:06:40 2023 +0100

    amended to isolate individual function to enable effecient unit testing

diff --git a/serverfinal.py b/serverfinal.py
index 6ac4481..dcb8fe2 100644
--- a/serverfinal.py
+++ b/serverfinal.py
@@ -2,27 +2,32 @@ import socket
 import pickle
 from cryptography.fernet import Fernet
 
-# Create a socket object
-server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
 
+def create_server_socket(address, port):    
+# Create a socket object
+    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
 # Bind the socket to a specific address and port
-server_address = ('localhost', 12345)
-server_socket.bind(server_address)
-
+#server_address = ('localhost', 12345)
+    server_socket.bind((address, port))
 # Listen for incoming connections
-server_socket.listen(1)
-print("Server is listening on {}:{}".format(*server_address))
+    server_socket.listen(1)
+    print("Server is listening on {}:{}".format(address, port))
+    return server_socket
 
+def accept_connection(server_socket):
 # Accept a connection
-client_socket, client_address = server_socket.accept()
-print("Accepted connection from {}:{}".format(*client_address))
+    client_socket, client_address = server_socket.accept()
+    print("Accepted connection from {}:{}".format(*client_address))
+    return client_socket
 
-try:
+def load_fernet_key(key_file_path):
     # Load the Fernet key
     with open("key.key", "rb") as key_file:
         key = key_file.read()
     print("Loaded key: ", key)
+    return key
 
+def receive_and_decrypt_data(client_socket, key):
     # Receive data from the client
     encrypted_data = client_socket.recv(1024)
     print("Received encrypted_data: ", encrypted_data)
@@ -31,31 +36,57 @@ try:
     f = Fernet(key)
     decrypted_data = f.decrypt(encrypted_data)
     print("Decryption successful.")
+    return decrypted_data
+
+def deserialize_data(data):
 
     # Print the decrypted data
     #print("Decrypted data:", decrypted_data.decode('utf-8'))
     #print("Decrypted data as bytes:", decrypted_data)
 
     # Deserialize the decrypted data using pickle
-    deserialized_data = pickle.loads(decrypted_data)
-
+    deserialized_data = pickle.loads(data)
     # Print the deserialized data
     print("Deserialized data:", deserialized_data)
+    return deserialize_data
 
+def save_decrypted_data_to_file(data, file_path):
     # Save the decrypted data to a file
-    with open('decrypted_dict.pickle', 'wb') as file:
-        pickle.dump(decrypted_data, file)
+    #with open('decrypted_dict.pickle', 'wb') as file:
+    with open(file_path, 'wb') as file:
+        pickle.dump(data, file)
+    print("Data saved to file:", file_path)
 
-    print("Received and decrypted data successfully.")
-
-    # Send a response back to the client
-    response = "Received and decrypted data successfully."
+def send_response(client_socket, response):
     client_socket.send(response.encode('utf-8'))
 
-except Exception as e:
-    print("Decryption failed:", e)
+def server_connection(
+    server_address='localhost',
+    server_port=12345,
+    key_file_path='key.key',
+    decrypted_data_file_path='decrypted_dict.pickle'
+):
+    try:
+        server_socket = create_server_socket(server_address, server_port)
+        client_socket = accept_connection(server_socket)
+
+        key = load_fernet_key(key_file_path)
+        decrypted_data = receive_and_decrypt_data(client_socket, key)
+        deserialized_data = deserialize_data(decrypted_data)
+        save_decrypted_data_to_file(deserialized_data, decrypted_data_file_path)
+
+   # Send a response back to the client
+        response = "Received and decrypted data successfully."
+        send_response(client_socket, response)
+        #client_socket.send(response.encode('utf-8'))
 
-finally:
+    except Exception as e:
+        print("Decryption failed:", e)
+
+    finally:
     # Clean up the connection
-    client_socket.close()
-    server_socket.close()
+        client_socket.close()
+        server_socket.close()
+
+if __name__ == "__main__":
+    server_connection()
\ No newline at end of file

commit f6b485fb9235bbae4ddcfce512bc3b86e7ec5d9e
Author: ThatalP <142354418+callmehawa@users.noreply.github.com>
Date:   Thu Oct 5 14:06:32 2023 +0100

    Create unit_test_server.yml
    
    Github action to run server unit test when changes are made to the main branch. Re-used unit test for client yml

diff --git a/.github/workflows/unit_test_server.yml b/.github/workflows/unit_test_server.yml
new file mode 100644
index 0000000..32bf314
--- /dev/null
+++ b/.github/workflows/unit_test_server.yml
@@ -0,0 +1,25 @@
+# This workflow will run unit test to check server functions whenever code is pushed to main branch or pulled from it.
+name: unit_test_client
+
+on:
+  push:
+    branches: [ "main" ] # Trigger the workflow on code pushes
+  pull_request:
+    branches: [ "main" ] # Trigger the workflow on pull request
+
+jobs:
+  test:
+    runs-on: windows-latest
+
+    steps:
+      - uses: actions/checkout@v3
+      - name: Set up Python 3.11
+        uses: actions/setup-python@v3
+        with:
+          python-version: "3.11"
+      - name: Install dependencies
+        run: |
+          pip install cryptography        # Install the 'cryptography' module
+
+      - name: Run unit tests
+        run: python -m unittest unit_tests_server.py

commit aff12472bceee3f13c6886dbdd602afe46b7ac87
Author: Paul Coleman <colemanp54@icloud.com>
Date:   Thu Oct 5 08:33:09 2023 +0100

    Mod' Changes.


commit 6989662a0d9d052a233e9781937cebee2a663742
Author: Paul Coleman <colemanp54@icloud.com>
Date:   Thu Oct 5 08:24:36 2023 +0100

    Changed Intro_added scope of pjt & format changes

diff --git a/Group C - Client Server Network Report.docx b/Group C - Client Server Network Report.docx
index ac03a81..1442f20 100644
--- a/Group C - Client Server Network Report.docx	
+++ b/Group C - Client Server Network Report.docx	
@@ -101,9 +101,21 @@ APPENDICES	8
 
 Introduction
 
-This Project is to establish a simple Client Server Network. This summative assignment is a practical exploration of a real-life project which involves gathering requirements, designing, and collaborating with the Project Manager, Architect, Developer and Tester to implement a simple client/server network. This assignment equips the team with essential skills for designing and managing networked systems in real-world scenarios.
+The objective of this project is create a Client Server Network which once established is capable of facilitating the transmission of encrypted and serialised files. Also the server must have the seamless mechanism for decrypting and processing these files on the server side.    
+SCOPE OF PROJECT
+The code and software architecture report will explain how Group C developed our Client Server Network and deployed it on to the local network. 
+The project needs to have three key functions:
+ Capable of Secure Communication between client and server.
+ Using Pickle  -  Serialising the data/encryption before transmission from client. 
+ Decrypting the data and demonstrating the information in required format by printing it. 
+Purpose of Report                                                                 
+This report and the related code created by Group C will demonstrate the following:
+ Understanding of network communication, creation and manipulation of data structures, 
+ Transmission of data between client and server, 
+ Implementation of advanced features such as data serialisation in various formats and encryption of text files.
+We decided to break this project into four roles of Project Manager, Architect, Developer and Testerto reflect how this project would be managed as a real time project in industry. This will enable Group C to acquire the essential skills for designing and managing networked systems in real-world scenarios whilst gaining an understanding of how data security works and the importance of privacy.via encryption
+
 
-Through this Project, Team C will demonstrate an understanding of network communication, the creation and manipulation of data structures, the transmission of data between client and server, and the implementation of advanced features such as data serialisation in various formats and encryption of text files.
 Solution Overview
                                        
 Solution overview
diff --git a/New File b/New File
new file mode 100644
index 0000000..e69de29

commit 252dd4f7ab0e783550b7dd079a288fa421899b46
Merge: 5800dd6 8af855d
Author: Paul Coleman <colemanp54@icloud.com>
Date:   Thu Oct 5 07:42:32 2023 +0100

    Merge branch 'main' of https://github.com/callmehawa/Client_Server_Network_GroupC

commit 8af855da37c82f45af59623e2cfdfdcbbec48407
Author: ThatalP <142354418+callmehawa@users.noreply.github.com>
Date:   Wed Oct 4 21:07:25 2023 +0100

    Update unit_test_client.yml
    
    added installation of cryptography using pip install

diff --git a/.github/workflows/unit_test_client.yml b/.github/workflows/unit_test_client.yml
index 98249e6..36de7c1 100644
--- a/.github/workflows/unit_test_client.yml
+++ b/.github/workflows/unit_test_client.yml
@@ -17,16 +17,9 @@ jobs:
         uses: actions/setup-python@v3
         with:
           python-version: "3.11"
-      #- name: Install dependencies
-       # run: |
-        #  python -m pip install --upgrade pip
-        #  pip install flake8 pytest
-        #  if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
-      #- name: Lint with flake8
-       # run: |
-        # stop the build if there are Python syntax errors or undefined names
-        #  flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
-          # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
-          #flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
+      - name: Install dependencies
+        run: |
+          pip install cryptography        # Install the 'cryptography' module
+
       - name: Run unit tests
         run: python -m unittest unit_tests_client.py

commit 3e9c0623ba6c224ae66cdc049209a3f87834c9c5
Author: ThatalP <142354418+callmehawa@users.noreply.github.com>
Date:   Wed Oct 4 20:57:10 2023 +0100

    Update unit_test_client.yml
    
    Corrected the name of unit test script

diff --git a/.github/workflows/unit_test_client.yml b/.github/workflows/unit_test_client.yml
index bf9e16e..98249e6 100644
--- a/.github/workflows/unit_test_client.yml
+++ b/.github/workflows/unit_test_client.yml
@@ -29,4 +29,4 @@ jobs:
           # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
           #flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
       - name: Run unit tests
-        run: python -m unittest unit_test_client.py
+        run: python -m unittest unit_tests_client.py

commit b5c2e66dcbad143abb623387ac78c87d5d390f36
Author: ThatalP <142354418+callmehawa@users.noreply.github.com>
Date:   Wed Oct 4 20:54:55 2023 +0100

    Update unit_test_client.yml
    
    Removed dependencies as there are none for this unit test. Also added doc string to explain went the test will be run.

diff --git a/.github/workflows/unit_test_client.yml b/.github/workflows/unit_test_client.yml
index ec837f0..bf9e16e 100644
--- a/.github/workflows/unit_test_client.yml
+++ b/.github/workflows/unit_test_client.yml
@@ -3,9 +3,9 @@ name: unit_test_client
 
 on:
   push:
-    branches: [ "main" ]
+    branches: [ "main" ] # Trigger the workflow on code pushes
   pull_request:
-    branches: [ "main" ]
+    branches: [ "main" ] # Trigger the workflow on pull request
 
 jobs:
   test:
@@ -17,15 +17,15 @@ jobs:
         uses: actions/setup-python@v3
         with:
           python-version: "3.11"
-      - name: Install dependencies
-        run: |
-          python -m pip install --upgrade pip
-          pip install flake8 pytest
-          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
-      - name: Lint with flake8
-        run: |
-         stop the build if there are Python syntax errors or undefined names
-          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
+      #- name: Install dependencies
+       # run: |
+        #  python -m pip install --upgrade pip
+        #  pip install flake8 pytest
+        #  if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
+      #- name: Lint with flake8
+       # run: |
+        # stop the build if there are Python syntax errors or undefined names
+        #  flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
           # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
           #flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
       - name: Run unit tests

commit 5ef1875c970588f25271e808f7ce0ffcf68bd5d8
Author: ThatalP <142354418+callmehawa@users.noreply.github.com>
Date:   Wed Oct 4 20:52:37 2023 +0100

    Update unit_test_client.yml
    
    Corrected indentation on "install dependencies"

diff --git a/.github/workflows/unit_test_client.yml b/.github/workflows/unit_test_client.yml
index f8f1f23..ec837f0 100644
--- a/.github/workflows/unit_test_client.yml
+++ b/.github/workflows/unit_test_client.yml
@@ -16,17 +16,17 @@ jobs:
       - name: Set up Python 3.11
         uses: actions/setup-python@v3
         with:
-        python-version: "3.11"
+          python-version: "3.11"
       - name: Install dependencies
         run: |
           python -m pip install --upgrade pip
           pip install flake8 pytest
           if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
-      #- name: Lint with flake8
-        #run: |
-        # stop the build if there are Python syntax errors or undefined names
+      - name: Lint with flake8
+        run: |
+         stop the build if there are Python syntax errors or undefined names
           flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
           # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
           #flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
-        - name: Run unit tests
+      - name: Run unit tests
         run: python -m unittest unit_test_client.py

commit bf55c2b6925c8c090fea91af526c31190230329c
Author: ThatalP <142354418+callmehawa@users.noreply.github.com>
Date:   Wed Oct 4 20:50:44 2023 +0100

    Update unit_test_client.yml
    
    updated script based on the previous error

diff --git a/.github/workflows/unit_test_client.yml b/.github/workflows/unit_test_client.yml
index bb7c214..f8f1f23 100644
--- a/.github/workflows/unit_test_client.yml
+++ b/.github/workflows/unit_test_client.yml
@@ -22,11 +22,11 @@ jobs:
           python -m pip install --upgrade pip
           pip install flake8 pytest
           if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
-      - name: Lint with flake8
-        run: |
+      #- name: Lint with flake8
+        #run: |
         # stop the build if there are Python syntax errors or undefined names
           flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
           # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
-          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
+          #flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
         - name: Run unit tests
         run: python -m unittest unit_test_client.py

commit e30462891b2aad045e18f6630decc07403049166
Author: ThatalP <142354418+callmehawa@users.noreply.github.com>
Date:   Wed Oct 4 20:48:53 2023 +0100

    Create unit_test_client.yml
    
    Created github action to run unit test every time code is pulled or committed to main branch

diff --git a/.github/workflows/unit_test_client.yml b/.github/workflows/unit_test_client.yml
new file mode 100644
index 0000000..bb7c214
--- /dev/null
+++ b/.github/workflows/unit_test_client.yml
@@ -0,0 +1,32 @@
+# This workflow will run unit test to check client functions whenever code is pushed to main branch or pulled from it.
+name: unit_test_client
+
+on:
+  push:
+    branches: [ "main" ]
+  pull_request:
+    branches: [ "main" ]
+
+jobs:
+  test:
+    runs-on: windows-latest
+
+    steps:
+      - uses: actions/checkout@v3
+      - name: Set up Python 3.11
+        uses: actions/setup-python@v3
+        with:
+        python-version: "3.11"
+      - name: Install dependencies
+        run: |
+          python -m pip install --upgrade pip
+          pip install flake8 pytest
+          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
+      - name: Lint with flake8
+        run: |
+        # stop the build if there are Python syntax errors or undefined names
+          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
+          # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
+          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
+        - name: Run unit tests
+        run: python -m unittest unit_test_client.py

commit 4ecb86c9e3aa454a57116823d64f928a53fb5f6d
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Wed Oct 4 19:56:08 2023 +0100

    separated the network-related function send_to_server which would allow mock the send_to_server function when performing unit tests

diff --git a/unit_tests_client.py b/unit_tests_client.py
new file mode 100644
index 0000000..56b238e
--- /dev/null
+++ b/unit_tests_client.py
@@ -0,0 +1,140 @@
+import unittest
+from unittest import mock
+import clientfinal
+import os
+#from cryptography.fernet import Fernet
+#from encryption import write_key, decrypt
+#from encryption import load_key
+#from encryption import encrypt
+
+
+class TestClient(unittest.TestCase):
+
+    def setUp(self):
+        # Create a key file for testing
+        with open("test_key.key", "wb") as key_file:
+            key_file.write(b"test_key")
+
+            # Comment - creating a file not required when using mock module
+            # Create a test file
+        #with open("test_file.txt", "w") as test_file:
+            #test_file.write("Test data")
+
+    def tearDown(self):
+        # Remove the key file if it exists after each test
+        #if os.path.exists("test_key.key"):
+            os.remove("test_key.key")
+    #comment - test file not created therefore not required
+        #if os.path.exists("test_file.txt"):
+          #  os.remove("test_file.txt")
+
+    def test_main(self):
+        print("Testing the main function...")
+        # Mock the functions and methods
+        create_client_socket_mock = mock.MagicMock()
+        connect_to_server_mock = mock.MagicMock()
+        write_key_mock = mock.MagicMock()
+        load_key_mock = mock.MagicMock(return_value=b"test_key")
+        encrypt_mock = mock.MagicMock(return_value=b"encrypted_data")
+        # Change the response from the server here
+        receive_response_mock = mock.MagicMock(return_value="Connection successful")
+
+        # Replace the functions and methods in the Client module with the mocks
+        clientfinal.create_client_socket = create_client_socket_mock
+        clientfinal.connect_to_server = connect_to_server_mock
+        clientfinal.write_key = write_key_mock
+        clientfinal.load_key = load_key_mock
+        clientfinal.encrypt = encrypt_mock
+        clientfinal.send_encrypted_data = mock.MagicMock()
+        clientfinal.receive_response = receive_response_mock
+
+        # Call the main function
+        clientfinal.main()
+
+        # Assertions to verify that functions and methods were called with the expected arguments
+        create_client_socket_mock.assert_called_once()
+        connect_to_server_mock.assert_called_once_with(create_client_socket_mock.return_value, ('localhost', 12345))
+        write_key_mock.assert_called_once()
+        load_key_mock.assert_called_once()
+        encrypt_mock.assert_called_once_with(
+            mock.ANY,  # Allow any serialized data argument here
+            b"test_key"  # Ensure the key argument is correct
+        )
+        
+        # Print the custom message from the client
+        #print("Message from client:", receive_response_mock.return_value)
+
+        # Print a test summary
+        print("Test summary:")
+        print("  - key generation, encryption and connection to server function was tested.")
+        print("  - All mocked functions were called with the expected arguments.")
+        print("  - Test completed successfully.")
+
+
+# functions - test_write_key, test_load_key, test_encrypt and test_decrypt no longer required. 
+# above functions will be called by mocking the functions and methods. 
+#mock assesertions will confirm test pass or fail. 
+
+
+    #def test_write_key(self):
+        # Create a key file for testing
+        #with open("key.key", "wb") as key_file:
+          # key_file.write(b"test_key")
+
+        # Call the function that will generate a key and save it to a file
+       # write_key()
+
+        # Check whether the key file was created
+        #self.assertTrue(os.path.exists("key.key"))
+
+        # Check whether the key file is not empty and saved to a file
+        #self.assertTrue(os.path.getsize("key.key") > 0)
+
+        # Clean up the key file after the test
+       # os.remove("key.key")
+
+    #def test_load_key(self):
+        # Call the function
+        #key = load_key()
+
+        # Check whether the correct key was loaded
+        #expected_key = b"test_key"
+       # self.assertEqual(expected_key, key)
+
+        # Remove the key file after the test
+       # os.remove("key.key")
+
+    #def test_encrypt(self):
+        # Generate a test key
+       # test_key = Fernet.generate_key()
+
+        # Call the function
+       # encrypt("test_file.txt", test_key)
+
+        # Read the encrypted file
+       # with open("test_file.txt", "rb") as encrypted_file:
+            #encrypted_data = encrypted_file.read()
+
+        # Check if the file data is encrypted
+        #self.assertNotEqual(encrypted_data, b"Test data")
+
+    #def test_decrypt(self):
+        # Generate a test key
+        #test_key = Fernet.generate_key()
+
+        # Encrypt the test file
+        #encrypt("test_file.txt", test_key)
+
+        # Call the function
+        #decrypt("test_file.txt", test_key)
+
+        # Read the decrypted file
+        #with open("test_file.txt", "rb") as decrypted_file:
+            #decrypted_data = decrypted_file.read()
+
+        # Check if the file data is decrypted correctly
+        #self.assertEqual(decrypted_data, b"Test data")
+
+
+if __name__ == '__main__':
+    unittest.main()

commit 27aa5ad56cc39cb54badf7b7536c64484e586308
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Wed Oct 4 19:55:14 2023 +0100

    cRefactored Olesia's unit test code to unit test using magic mock module

diff --git a/unit_tests_encryption.py b/unit_tests_encryption.py
deleted file mode 100644
index 7a1eebd..0000000
--- a/unit_tests_encryption.py
+++ /dev/null
@@ -1,86 +0,0 @@
-import unittest
-import os
-from cryptography.fernet import Fernet
-from encryption import write_key, decrypt
-from encryption import load_key
-from encryption import encrypt
-
-
-class testEncryption(unittest.TestCase):
-
-    def setUp(self):
-        # Create a key file for testing
-        with open("key.key", "wb") as key_file:
-            key_file.write(b"test_key")
-            # Create a test file
-        with open("test_file.txt", "w") as test_file:
-            test_file.write("Test data")
-    def tearDown(self):
-        # Remove the key file if it exists after each test
-        if os.path.exists("key.key"):
-            os.remove("key.key")
-        if os.path.exists("test_file.txt"):
-            os.remove("test_file.txt")
-
-    def test_write_key(self):
-        # Create a key file for testing
-        with open("key.key", "wb") as key_file:
-            key_file.write(b"test_key")
-
-        # Call the function that will generate a key and save it to a file
-        write_key()
-
-        # Check whether the key file was created
-        self.assertTrue(os.path.exists("key.key"))
-
-        # Check whether the key file is not empty and saved to a file
-        self.assertTrue(os.path.getsize("key.key") > 0)
-
-        # Clean up the key file after the test
-        os.remove("key.key")
-
-    def test_load_key(self):
-        # Call the function
-        key = load_key()
-
-        # Check whether the correct key was loaded
-        expected_key = b"test_key"
-        self.assertEqual(expected_key, key)
-
-        # Remove the key file after the test
-        os.remove("key.key")
-
-    def test_encrypt(self):
-        # Generate a test key
-        test_key = Fernet.generate_key()
-
-        # Call the function
-        encrypt("test_file.txt", test_key)
-
-        # Read the encrypted file
-        with open("test_file.txt", "rb") as encrypted_file:
-            encrypted_data = encrypted_file.read()
-
-        # Check if the file data is encrypted
-        self.assertNotEqual(encrypted_data, b"Test data")
-
-    def test_decrypt(self):
-        # Generate a test key
-        test_key = Fernet.generate_key()
-
-        # Encrypt the test file
-        encrypt("test_file.txt", test_key)
-
-        # Call the function
-        decrypt("test_file.txt", test_key)
-
-        # Read the decrypted file
-        with open("test_file.txt", "rb") as decrypted_file:
-            decrypted_data = decrypted_file.read()
-
-        # Check if the file data is decrypted correctly
-        self.assertEqual(decrypted_data, b"Test data")
-
-
-if __name__ == '__main__':
-    unittest.main()

commit 541bb3db61677027d8cb00c66fd7aee579a5619d
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Wed Oct 4 19:54:29 2023 +0100

    update to clientfinal.py to allow mock of network related function so that unit_tests can run without having to connect to server or client

diff --git a/clientfinal.py b/clientfinal.py
index 5ac2c09..2ca36a1 100644
--- a/clientfinal.py
+++ b/clientfinal.py
@@ -3,14 +3,23 @@ import pickle
 from cryptography.fernet import Fernet
 import sys
 
-# Create a socket object
-client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+def create_client_socket():
+    """Create and return a socket object for the client. 
+        Created fucntion for socket to enable unit testing using magic mock
+    """
+    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+    return client_socket
+
+def connect_to_server(client_socket, server_address):
+    """
+    Connect to the server using the provided socket and server address.
+    Created fucntion for socket to enable unit testing using magic mock
 
-# Server address and port
-server_address = ('localhost', 12345)
+    """
+    client_socket.connect(server_address)
 
-# Connect to the server
-client_socket.connect(server_address)
+   # server_address = ('localhost', 12345)
+   # client_socket.connect(server_address)
 
 def write_key():
     """
@@ -23,68 +32,122 @@ def write_key():
     with open("key.key", "wb") as key_file:
         key_file.write(key)
 
-def load_key():
+def write_key(key_filename="key.key"):
     """
-    Load the cryptographic key from the 'key.key' file.
-
-    Returns:
-        bytes: The Fernet key loaded from the 'key.key' file.
-    Loading the key from the current directory named `key.key`
+    Generate a cryptographic key and save it to a file.
+    This function generates a Fernet key and saves it to a specified file in binary format.
     """
-    return open("key.key", "rb").read()
+    key = Fernet.generate_key()
+    with open(key_filename, "wb") as key_file:
+        key_file.write(key)
+   #return open("key.key", "rb").read()
 
 # Generate and write a new key
-write_key()
+#write_key()
 
 # Load the previously generated key and print it
-key = load_key()
-print(f"Fernet Key: {key.hex()}")
+#key = load_key()
+#print(f"Fernet Key: {key.hex()}")
 #write_key()
 
-try:
-    # Add a new dictionary
-    dictionary = {"name": "Pawan", "age": 40, "city": "Preston"}
-
-    # Create a file to serialize into pickle
-    with open('dict.pickle', 'wb') as file:
-        pickle.dump(dictionary, file)
+def load_key(key_filename="key.key"):
+    """
+    Load the cryptographic key from the specified file.
 
-    # Read the serialized data from the file
-    with open('dict.pickle', 'rb') as file:
-        serialised_data = file.read()
+    Returns:
+        bytes: The Fernet key loaded from the file.
+    """
+    return open(key_filename, "rb").read()
 
-    def encrypt(data, key):
-        """
-        Encrypt data using a Fernet key.
+def encrypt(data, key):
+    """
+    Encrypt data using a Fernet key.
 
-        Args:
-            data (bytes): The data to be encrypted.
-            key (bytes): The Fernet key used for encryption.
+    Args:
+        data (bytes): The data to be encrypted.
+        key (bytes): The Fernet key used for encryption.
 
-        Returns:
+    Returns:
             bytes: The encrypted data.
-        """
-        f = Fernet(key)
-        encrypted_data = f.encrypt(data)
-        return encrypted_data
+    """
+    f = Fernet(key)
+    encrypted_data = f.encrypt(data)
+    return encrypted_data
+
+def send_encrypted_data(client_socket, encrypted_data):
+    """
+    Send encrypted data to the server using the provided socket.
+
+    Args:
+        client_socket (socket.socket): The client socket object.
+        encrypted_data (bytes): The encrypted data to send
+    """
+
+    client_socket.send(encrypted_data)
+
+def receive_response(client_socket, buffer_size=1024):
+    """
+    Receive a response from the server using the provided socket.
+
+    Args:
+        client_socket (socket.socket): The client socket object.
+        buffer_size (int): The size of the buffer for receiving data.
+
+    Returns:
+        str: The received response as a string.
+    """
+    response = client_socket.recv(buffer_size)
+    return response.decode('utf-8')
+
+def main():
+    try:
+        client_socket = create_client_socket()
+
+        server_address = ('localhost', 12345)
+        connect_to_server(client_socket, server_address)
+
+        # Generate and write a new key
+        write_key()
+
+        # Load the previously generated key
+        key = load_key()
+
+    # Add a new dictionary
+        dictionary = {"name": "Pawan", "age": 40, "city": "Preston"}
+
+    # Create a file to serialise into pickle
+        with open('dict.pickle', 'wb') as file:
+            pickle.dump(dictionary, file)
+
+    # Read the serialized data from the file
+        with open('dict.pickle', 'rb') as file:
+            serialised_data = file.read()
 
     # Encrypt the serialized data
-    encrypted_data = encrypt(serialised_data, key)
+        encrypted_data = encrypt(serialised_data, key)
 
     # Send encrypted data to the server
-    client_socket.send(encrypted_data)
+        client_socket.send(encrypted_data)
+    
+    # Send encrypted data to the server
+        send_encrypted_data(client_socket, encrypted_data)
 
     # Receive a response from the server
-    response = client_socket.recv(1024)
-    print(f"Message from server: {response.decode('utf-8')}")
+        response = receive_response(client_socket)
+        print(f"Message from server: {response}")
+        #response = client_socket.recv(1024)
+        #print(f"Message from server: {response.decode('utf-8')}")
 
-except Exception as e:
-    """
-    try-except block to handle excpetion and print error message
-    """
-    print(f"An error occurred: {e}")
-    sys.exit(1)
+    except Exception as e:
+        """
+        try-except block to handle excpetion and print error message
+        """
+        print(f"An error occurred: {e}")
+    #sys.exit(1)
 
-finally:
+    finally:
     # Clean up the connection
-    client_socket.close()
+        client_socket.close()
+        
+if __name__ == '__main__':
+    main()
\ No newline at end of file

commit 408609ff460a3b6ff2e9faf7bddb2bc786377c74
Author: nicolasKappa <nicola.kappa8@gmail.com>
Date:   Wed Oct 4 15:49:51 2023 +0400

    Updated Serverfinal.py and clientfinal.py

diff --git a/serverfinal.py b/serverfinal.py
index 45aef6c..6ac4481 100644
--- a/serverfinal.py
+++ b/serverfinal.py
@@ -19,7 +19,8 @@ print("Accepted connection from {}:{}".format(*client_address))
 
 try:
     # Load the Fernet key
-    key = open("key.key", "rb").read()
+    with open("key.key", "rb") as key_file:
+        key = key_file.read()
     print("Loaded key: ", key)
 
     # Receive data from the client
@@ -43,7 +44,7 @@ try:
 
     # Save the decrypted data to a file
     with open('decrypted_dict.pickle', 'wb') as file:
-        file.write(decrypted_data)
+        pickle.dump(decrypted_data, file)
 
     print("Received and decrypted data successfully.")
 

commit 7db8a026095697c402170f012e626b344a19699f
Author: nicolasKappa <nicola.kappa8@gmail.com>
Date:   Wed Oct 4 15:07:09 2023 +0400

    some changes on clientfinela.py

diff --git a/clientfinal.py b/clientfinal.py
index ad16003..5ac2c09 100644
--- a/clientfinal.py
+++ b/clientfinal.py
@@ -1,6 +1,7 @@
 import socket
 import pickle
 from cryptography.fernet import Fernet
+import sys
 
 # Create a socket object
 client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
@@ -35,12 +36,9 @@ def load_key():
 # Generate and write a new key
 write_key()
 
-# Load the previously generated key
+# Load the previously generated key and print it
 key = load_key()
-#print(f"Fernet Key: {key.hex()}")
-
-# Call the print_key function to print the key
-load_key()
+print(f"Fernet Key: {key.hex()}")
 #write_key()
 
 try:

commit 5800dd65b7d244c4c36b807da9a996d99f43daf9
Author: Paul Coleman <colemanp54@icloud.com>
Date:   Tue Oct 3 18:10:50 2023 +0100

    Client_Test_file

commit 65379432e592f04f40118af8816c2419b1a643cb
Author: Paul Coleman <colemanp54@icloud.com>
Date:   Tue Oct 3 18:09:17 2023 +0100

    Commit Socket Server Code

diff --git a/client_file b/client_file
new file mode 100644
index 0000000..ad16003
--- /dev/null
+++ b/client_file
@@ -0,0 +1,92 @@
+import socket
+import pickle
+from cryptography.fernet import Fernet
+
+# Create a socket object
+client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+
+# Server address and port
+server_address = ('localhost', 12345)
+
+# Connect to the server
+client_socket.connect(server_address)
+
+def write_key():
+    """
+    Generate a cryptographic key and save it to a file.
+
+    This function generates a Fernet key and saves it to a file named 'key.key' in binary format.
+    Generating a key and saving it into a file
+    """
+    key = Fernet.generate_key()
+    with open("key.key", "wb") as key_file:
+        key_file.write(key)
+
+def load_key():
+    """
+    Load the cryptographic key from the 'key.key' file.
+
+    Returns:
+        bytes: The Fernet key loaded from the 'key.key' file.
+    Loading the key from the current directory named `key.key`
+    """
+    return open("key.key", "rb").read()
+
+# Generate and write a new key
+write_key()
+
+# Load the previously generated key
+key = load_key()
+#print(f"Fernet Key: {key.hex()}")
+
+# Call the print_key function to print the key
+load_key()
+#write_key()
+
+try:
+    # Add a new dictionary
+    dictionary = {"name": "Pawan", "age": 40, "city": "Preston"}
+
+    # Create a file to serialize into pickle
+    with open('dict.pickle', 'wb') as file:
+        pickle.dump(dictionary, file)
+
+    # Read the serialized data from the file
+    with open('dict.pickle', 'rb') as file:
+        serialised_data = file.read()
+
+    def encrypt(data, key):
+        """
+        Encrypt data using a Fernet key.
+
+        Args:
+            data (bytes): The data to be encrypted.
+            key (bytes): The Fernet key used for encryption.
+
+        Returns:
+            bytes: The encrypted data.
+        """
+        f = Fernet(key)
+        encrypted_data = f.encrypt(data)
+        return encrypted_data
+
+    # Encrypt the serialized data
+    encrypted_data = encrypt(serialised_data, key)
+
+    # Send encrypted data to the server
+    client_socket.send(encrypted_data)
+
+    # Receive a response from the server
+    response = client_socket.recv(1024)
+    print(f"Message from server: {response.decode('utf-8')}")
+
+except Exception as e:
+    """
+    try-except block to handle excpetion and print error message
+    """
+    print(f"An error occurred: {e}")
+    sys.exit(1)
+
+finally:
+    # Clean up the connection
+    client_socket.close()

commit c4f8f19f6a43ad1e738658fb3048b1fa141fc54f
Merge: f349b02 f5dfcd6
Author: saorscarr <144169059+saorscarr@users.noreply.github.com>
Date:   Tue Oct 3 17:57:08 2023 +0100

    Merge pull request #5 from callmehawa/tests_encryption
    
    added unit tests for encryption - reviewed

commit f349b02778c66b2eddd234ee668c6a89ed9ac4f4
Merge: 184206c e02388e
Author: saorscarr <144169059+saorscarr@users.noreply.github.com>
Date:   Tue Oct 3 17:55:51 2023 +0100

    Merge pull request #4 from callmehawa/encrypt
    
    Encrypt - Reviewed all correct.

commit f5dfcd6100397973123f048b407dd99d71fed5f3
Author: Olesia Shtern <olesya0789@gmail.com>
Date:   Tue Oct 3 15:15:46 2023 +0300

    added unit tests for encryption

diff --git a/__pycache__/encryption.cpython-311.pyc b/__pycache__/encryption.cpython-311.pyc
new file mode 100644
index 0000000..1512564
Binary files /dev/null and b/__pycache__/encryption.cpython-311.pyc differ
diff --git a/__pycache__/unit_tests_encryption.cpython-311.pyc b/__pycache__/unit_tests_encryption.cpython-311.pyc
new file mode 100644
index 0000000..23abf82
Binary files /dev/null and b/__pycache__/unit_tests_encryption.cpython-311.pyc differ
diff --git a/unit_tests_encryption.py b/unit_tests_encryption.py
new file mode 100644
index 0000000..7a1eebd
--- /dev/null
+++ b/unit_tests_encryption.py
@@ -0,0 +1,86 @@
+import unittest
+import os
+from cryptography.fernet import Fernet
+from encryption import write_key, decrypt
+from encryption import load_key
+from encryption import encrypt
+
+
+class testEncryption(unittest.TestCase):
+
+    def setUp(self):
+        # Create a key file for testing
+        with open("key.key", "wb") as key_file:
+            key_file.write(b"test_key")
+            # Create a test file
+        with open("test_file.txt", "w") as test_file:
+            test_file.write("Test data")
+    def tearDown(self):
+        # Remove the key file if it exists after each test
+        if os.path.exists("key.key"):
+            os.remove("key.key")
+        if os.path.exists("test_file.txt"):
+            os.remove("test_file.txt")
+
+    def test_write_key(self):
+        # Create a key file for testing
+        with open("key.key", "wb") as key_file:
+            key_file.write(b"test_key")
+
+        # Call the function that will generate a key and save it to a file
+        write_key()
+
+        # Check whether the key file was created
+        self.assertTrue(os.path.exists("key.key"))
+
+        # Check whether the key file is not empty and saved to a file
+        self.assertTrue(os.path.getsize("key.key") > 0)
+
+        # Clean up the key file after the test
+        os.remove("key.key")
+
+    def test_load_key(self):
+        # Call the function
+        key = load_key()
+
+        # Check whether the correct key was loaded
+        expected_key = b"test_key"
+        self.assertEqual(expected_key, key)
+
+        # Remove the key file after the test
+        os.remove("key.key")
+
+    def test_encrypt(self):
+        # Generate a test key
+        test_key = Fernet.generate_key()
+
+        # Call the function
+        encrypt("test_file.txt", test_key)
+
+        # Read the encrypted file
+        with open("test_file.txt", "rb") as encrypted_file:
+            encrypted_data = encrypted_file.read()
+
+        # Check if the file data is encrypted
+        self.assertNotEqual(encrypted_data, b"Test data")
+
+    def test_decrypt(self):
+        # Generate a test key
+        test_key = Fernet.generate_key()
+
+        # Encrypt the test file
+        encrypt("test_file.txt", test_key)
+
+        # Call the function
+        decrypt("test_file.txt", test_key)
+
+        # Read the decrypted file
+        with open("test_file.txt", "rb") as decrypted_file:
+            decrypted_data = decrypted_file.read()
+
+        # Check if the file data is decrypted correctly
+        self.assertEqual(decrypted_data, b"Test data")
+
+
+if __name__ == '__main__':
+    unittest.main()

commit e02388e0e155b679e7450a9fc8df0addba5f37de
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Tue Oct 3 12:34:23 2023 +0100

    added error handling using try-excpet block

diff --git a/clientfinal.py b/clientfinal.py
index 48807d4..ad16003 100644
--- a/clientfinal.py
+++ b/clientfinal.py
@@ -80,6 +80,13 @@ try:
     response = client_socket.recv(1024)
     print(f"Message from server: {response.decode('utf-8')}")
 
+except Exception as e:
+    """
+    try-except block to handle excpetion and print error message
+    """
+    print(f"An error occurred: {e}")
+    sys.exit(1)
+
 finally:
     # Clean up the connection
     client_socket.close()

commit d4b75a0011264e6dd561b9c5a41a3e4ebc5331e6
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Tue Oct 3 12:27:54 2023 +0100

    replaced printing binary to print serialised format using pickle module

diff --git a/serverfinal.py b/serverfinal.py
index b6d4951..45aef6c 100644
--- a/serverfinal.py
+++ b/serverfinal.py
@@ -1,4 +1,5 @@
 import socket
+import pickle
 from cryptography.fernet import Fernet
 
 # Create a socket object
@@ -32,7 +33,13 @@ try:
 
     # Print the decrypted data
     #print("Decrypted data:", decrypted_data.decode('utf-8'))
-    print("Decrypted data as bytes:", decrypted_data)
+    #print("Decrypted data as bytes:", decrypted_data)
+
+    # Deserialize the decrypted data using pickle
+    deserialized_data = pickle.loads(decrypted_data)
+
+    # Print the deserialized data
+    print("Deserialized data:", deserialized_data)
 
     # Save the decrypted data to a file
     with open('decrypted_dict.pickle', 'wb') as file:

commit 617e1eaccc2426d7e64bd3951b98f89364f15407
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Tue Oct 3 12:26:55 2023 +0100

    removed printing of key as it is no longer required

diff --git a/clientfinal.py b/clientfinal.py
index 2d4856b..48807d4 100644
--- a/clientfinal.py
+++ b/clientfinal.py
@@ -37,11 +37,11 @@ write_key()
 
 # Load the previously generated key
 key = load_key()
-print(f"Fernet Key: {key.hex()}")
+#print(f"Fernet Key: {key.hex()}")
 
 # Call the print_key function to print the key
 load_key()
-write_key()
+#write_key()
 
 try:
     # Add a new dictionary

commit 942239216b381d2359ee9802308b11dcf44fedca
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Tue Oct 3 12:13:18 2023 +0100

    updated the report and included design section

diff --git a/Group C - Client Server Network Report.docx b/Group C - Client Server Network Report.docx
index 2ea4cbf..ac03a81 100644
--- a/Group C - Client Server Network Report.docx	
+++ b/Group C - Client Server Network Report.docx	
@@ -133,8 +133,8 @@ The Technical Flow diagram (Figure 2) showcases the process flow of a Client-Ser
 
 
 
-Solution Design (Client)
-Solution Design (Server) 
+Solution Design
+Solution Design (Client) 
 
                                        
                                        
@@ -168,10 +168,10 @@ Encryption: Fernet Cryptographic protocol will be used as our encryption tool of
  Fernet is built on AES (Advance Encryption Standard) and ensures data encrypted is well-protected. 
 
 
-Testing
+Unit Testing
 Serialization Unit Testing
 Encryption Unit Testing
-Network Unit Testing
+
 
 
 Conclusion
@@ -192,7 +192,7 @@ Requirement.txt
 4
 Readme.md
 5
-Log of Github code review
+Screenshot of Github repo
 6
-Log of Github push comments
+Screenshot of Logs
 

commit 5f163bc2d75bbcedb4dbed35bc5d63444fcddfa5
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Tue Oct 3 12:12:33 2023 +0100

    Server code amended to include deserialisation, decryption and printing of the file. This code also includes debugging steps and error handling. Note this is a cobination of server.py and encryption.py

diff --git a/serverfinal.py b/serverfinal.py
new file mode 100644
index 0000000..b6d4951
--- /dev/null
+++ b/serverfinal.py
@@ -0,0 +1,53 @@
+import socket
+from cryptography.fernet import Fernet
+
+# Create a socket object
+server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+
+# Bind the socket to a specific address and port
+server_address = ('localhost', 12345)
+server_socket.bind(server_address)
+
+# Listen for incoming connections
+server_socket.listen(1)
+print("Server is listening on {}:{}".format(*server_address))
+
+# Accept a connection
+client_socket, client_address = server_socket.accept()
+print("Accepted connection from {}:{}".format(*client_address))
+
+try:
+    # Load the Fernet key
+    key = open("key.key", "rb").read()
+    print("Loaded key: ", key)
+
+    # Receive data from the client
+    encrypted_data = client_socket.recv(1024)
+    print("Received encrypted_data: ", encrypted_data)
+
+    # Decrypt the data using the key
+    f = Fernet(key)
+    decrypted_data = f.decrypt(encrypted_data)
+    print("Decryption successful.")
+
+    # Print the decrypted data
+    #print("Decrypted data:", decrypted_data.decode('utf-8'))
+    print("Decrypted data as bytes:", decrypted_data)
+
+    # Save the decrypted data to a file
+    with open('decrypted_dict.pickle', 'wb') as file:
+        file.write(decrypted_data)
+
+    print("Received and decrypted data successfully.")
+
+    # Send a response back to the client
+    response = "Received and decrypted data successfully."
+    client_socket.send(response.encode('utf-8'))
+
+except Exception as e:
+    print("Decryption failed:", e)
+
+finally:
+    # Clean up the connection
+    client_socket.close()
+    server_socket.close()

commit 79e4ef09e922b5afe3cfe9014ef0411f058dd90b
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Tue Oct 3 12:10:20 2023 +0100

    Client code amended to include serialisation using pickle module and encryption before sending the file to server. Note this file is combination of client.py, dictionary.py and encryption.py

diff --git a/clientfinal.py b/clientfinal.py
new file mode 100644
index 0000000..2d4856b
--- /dev/null
+++ b/clientfinal.py
@@ -0,0 +1,85 @@
+import socket
+import pickle
+from cryptography.fernet import Fernet
+
+# Create a socket object
+client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+
+# Server address and port
+server_address = ('localhost', 12345)
+
+# Connect to the server
+client_socket.connect(server_address)
+
+def write_key():
+    """
+    Generate a cryptographic key and save it to a file.
+
+    This function generates a Fernet key and saves it to a file named 'key.key' in binary format.
+    Generating a key and saving it into a file
+    """
+    key = Fernet.generate_key()
+    with open("key.key", "wb") as key_file:
+        key_file.write(key)
+
+def load_key():
+    """
+    Load the cryptographic key from the 'key.key' file.
+
+    Returns:
+        bytes: The Fernet key loaded from the 'key.key' file.
+    Loading the key from the current directory named `key.key`
+    """
+    return open("key.key", "rb").read()
+
+# Generate and write a new key
+write_key()
+
+# Load the previously generated key
+key = load_key()
+print(f"Fernet Key: {key.hex()}")
+
+# Call the print_key function to print the key
+load_key()
+write_key()
+
+try:
+    # Add a new dictionary
+    dictionary = {"name": "Pawan", "age": 40, "city": "Preston"}
+
+    # Create a file to serialize into pickle
+    with open('dict.pickle', 'wb') as file:
+        pickle.dump(dictionary, file)
+
+    # Read the serialized data from the file
+    with open('dict.pickle', 'rb') as file:
+        serialised_data = file.read()
+
+    def encrypt(data, key):
+        """
+        Encrypt data using a Fernet key.
+
+        Args:
+            data (bytes): The data to be encrypted.
+            key (bytes): The Fernet key used for encryption.
+
+        Returns:
+            bytes: The encrypted data.
+        """
+        f = Fernet(key)
+        encrypted_data = f.encrypt(data)
+        return encrypted_data
+
+    # Encrypt the serialized data
+    encrypted_data = encrypt(serialised_data, key)
+
+    # Send encrypted data to the server
+    client_socket.send(encrypted_data)
+
+    # Receive a response from the server
+    response = client_socket.recv(1024)
+    print(f"Message from server: {response.decode('utf-8')}")
+
+finally:
+    # Clean up the connection
+    client_socket.close()

commit 184206cab707f58c0960864fbfebf7581e6730b6
Merge: 1f76190 9023447
Author: saorscarr <144169059+saorscarr@users.noreply.github.com>
Date:   Mon Oct 2 19:30:57 2023 +0100

    Merge pull request #3 from callmehawa/encrypt
    
    Added Introduction, solution design, added summary of activities for …

commit 902344737b27f57bb02c0e8985d1a546d6c54016
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Mon Oct 2 16:33:39 2023 +0100

    Added Introduction, soultion design, added summary of activities for solution design for client and server, formatted the document

diff --git a/Group C - Client Server Network Report.docx b/Group C - Client Server Network Report.docx
index 92cb574..2ea4cbf 100644
--- a/Group C - Client Server Network Report.docx	
+++ b/Group C - Client Server Network Report.docx	
@@ -1,6 +1,6 @@
 
 
-REPORT TITLE
+Client server network project
 
 
 
@@ -21,19 +21,18 @@ The University of Liverpool
 
 
 
-MASTER-OF-SCIENCE-TITLE
+MASTER-OF-COMPUTER-SCIENCE
 
 
-Module-Name
+Software Development in Practice
 
 
 Word Count: XXX
 
 
-{The Word Count does take into consideration all sections between the Introduction and Conclusions included. Please, do not include the amount of words used for references, title page, ToC, LoT, LoF.}
                                        
 
-dd/mm/20xx
+09/Oct/2023
 
 
 
@@ -74,82 +73,51 @@ Word Count: XXX
 
                                        
 
-dd/mm/20x
+09/Oct/2023
 
 
 TABLE OF CONTENTS
          
 	Page
-Chapter 1. Introduction	3
-Chapter 2. Solution Design	4
-2.1	Solution overview	4
-2.2	Technical Flow	5
-2.3	Solution Design (Client)	5
-2.4	Solution Design (Server) 	6
-2.5	Design Decision	6
-Chapter 3. Testing	6
-3.1	Serialization Unit Testing	7
-3.2	Encryption Unit Testing	7
-3.3	Network Unit Testing	7
-3.4	File Transfer Unit Testing	7
-3.5	Decryption Unit Testing	7
-3.6	De-Serialization Unit Testing	7
-3.7	Integration Testing	7
-Chapter 4. Conclusion	7
+Chapter 1. Introduction	2
+Chapter 2. Solution Overview	3
+2.1	Solution overview	3
+2.2	Technical Flow	4
+Chapter 3. Solution Design (Client)	5
+3.1	Solution Design (Server)	5
+3.2	Solution Design (Server)	5
+3.3	Error Handling	6
+3.4	Design Decisions	6
+Chapter 4. Testing	6
+4.1	Serialization Unit Testing	6
+4.2	Encryption Unit Testing	6
+4.3	Network Unit Testing	6
+Chapter 5. Conclusion	7
 REFERENCES	8
 APPENDICES	8
-	
-	
-		
-		
-		
-	
-		
-		
-		
-		
-		
-		
-		
-	
-	
-	
 
                     
-{To update the LIST OF FIGURES, right click on the entries, chose "Update Field", choose "Update entire table" and click on OK}
 
 
 Introduction
-{This chapter introduces the Report, its aims and objectives, the IT artefact to be investigated, the problem, the question(s), approach and potential outcome.}
 
+This Project is to establish a simple Client Server Network. This summative assignment is a practical exploration of a real-life project which involves gathering requirements, designing, and collaborating with the Project Manager, Architect, Developer and Tester to implement a simple client/server network. This assignment equips the team with essential skills for designing and managing networked systems in real-world scenarios.
 
-Solution Design
-{This chapter represents the main section of your report. It develops argument point by point, including the reasons that support the argument you declared in your introduction.)
+Through this Project, Team C will demonstrate an understanding of network communication, the creation and manipulation of data structures, the transmission of data between client and server, and the implementation of advanced features such as data serialisation in various formats and encryption of text files.
+Solution Overview
                                        
 Solution overview
                                        
-                                       
+Figure 1 is a high-level solution of a simple client-server network to perform data serialisation, encryption, and transfer from a server to a client. 
                           Figure 1. Solution overview
 Technical Flow
+The Technical Flow diagram (Figure 2) showcases the process flow of a Client-Server network that accomodates various data formats and encrypts the data to protect transmitted information. It also showcases server actions to accept the transmited data, de-seralise, unencrpt and print the received data.  
+
 
                            Figure 2. Technical Flow
-Solution Design (Client)
 
-                                       
-                                       
 
-Description of activities
-1
-User to input as Dictionary. 
 
-2
-File is serialised using Pickle module JSON
-3
-File is encrypted using Cryptography modules Fernet Object 
-4
-Token is generated to encrypt the file 
-5
-Error handling will check if the file has been written
 
 
 
@@ -159,43 +127,55 @@ Error handling will check if the file has been written
 
 
 
+
+
+
+
+
+
+Solution Design (Client)
 Solution Design (Server) 
-   
 
-Description of activities
-1
-Server to listen to incoming calls
-2
-Server receives the file and decrypts
-3
-File is de-serialised
-4
-Received file is printed.
-Design Decision
+                                       
+                                       
+Key components within the Client design
+
+    Serialisation: Serialise the data into a structured format to maintain data integrity and interoperability. 
+    Key Management: The key management component is responsible for generating and managing encryption keys.
+    Encryption: The encryption component is responsible for encrypting and decrypting data using the encryption keys provided by the key management component.
+ Client: The client is responsible for sending encrypted data
+Solution Design (Server) 
 
-Design decisions
-1
-Agreed to use json formatting for serialisation since json is compact, concise and easier to read.
 
 
-2
-Fernet Object will be used for encrypting the file due to it's simplicity and easy of use. Fernet is a symmetric encryption algorithm, meaning it uses the same key for both encryption and decryption  
+
+Key components within the Server design 
+ Server: The server opens a socket to listen for incoming client connections. Once a connection is established, the server receives the file from the client. The server receives the file from the client. using a TCP Protocol.
+ Decryption: The server decrypts the file using the same key used to encrypt it. This will be done via the Fernet Key generated by the client. This key will be supplied along with the file. 
+ De-serialisation: The server de-serialises the data in the file to a json format.
+ Print: The server prints the contents of the dictionary.
+   
+Error Handling
+Design Decisions
+
+Serialisation: Pickle module is used to serialise the dictionary into JSON format for the following reasons  -  
+ JSON is a text-based format that is easy to read and write.
+ It is a language-agnostic format and interoperability between systems written in different languages.
+ It is a lightweight format with minimal overhead.
+
+Encryption: Fernet Cryptographic protocol will be used as our encryption tool of choice for the following reasons - 
+ Fernet uses symmetric key cryptography, which is simple and easy to use.  
+ Fernet is built on AES (Advance Encryption Standard) and ensures data encrypted is well-protected. 
 
 
 Testing
-{This final chapter serves as a summary of the project from a holistic perspective.  It includes a critical review of the achievements and limitations of the project, from both an academic and business perspective.  It includes suggestions for potential research in the future}
 Serialization Unit Testing
 Encryption Unit Testing
 Network Unit Testing
-File Transfer Unit Testing
-Decryption Unit Testing
-De-Serialization Unit Testing
-Integration Testing
+
 
 Conclusion
 REFERENCES
-{The purpose of a citation is to lead the reader to the correct reference entry. If it is a quote, the in-text citation includes the page of the quote so that the reader goes to the reference entry to access the source and then the page. Only sources actually cited are included in a reference section. You may have had other sources you read but ended up not citing. They are not included in the References listing. 
-This section includes all references cited, using the Harvard-style referencing format as described within the University Library portal.} 
 
 
 

commit 1f7619041bfeabd450ff6c9f67931a39a7ab4678
Merge: b339173 69d652c
Author: ThatalP <142354418+callmehawa@users.noreply.github.com>
Date:   Mon Oct 2 12:32:43 2023 +0100

    Merge pull request #2 from callmehawa/encrypt
    
    Encrypt

commit 69d652c3a6afb6b396cecc31e0627ac3a289b318
Merge: 93ea804 b339173
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Mon Oct 2 12:30:23 2023 +0100

    Merge branch 'main' into encrypt

commit 93ea8049d41337398f506fc7078d8a9de4b9407d
Merge: 2d12c87 2d93e30
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Mon Oct 2 12:29:47 2023 +0100

    Merge branch 'encrypt' of https://github.com/callmehawa/Client_Server_Network_GroupC into encrypt

commit 2d12c873e2aedfc79cff8213d46903b397efbc43
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Mon Oct 2 12:22:49 2023 +0100

    json file committed to resolve merge issue

diff --git a/encrypted_data.json b/encrypted_data.json
new file mode 100644
index 0000000..d89d544
--- /dev/null
+++ b/encrypted_data.json
@@ -0,0 +1 @@
+gAAAAABlFe3LbXD8lwFg4-lE_fBBtFBXsVvxwQG9wg8qtnv1Rf5kHVwZ6fUqaXX9HQAaD4FRYw2QZv_VSQ_o7BjxCdeyfIAqW7jSno5jYeeQad2arspyaC2OKzQ6jZhCXN6u8OtVbH9t
\ No newline at end of file

commit b33917378c65783b0257b06c443efb26a17d41e8
Author: Paul Coleman <colemanp54@icloud.com>
Date:   Fri Sep 29 15:20:19 2023 +0100

    Commit Socket Server Changes

diff --git a/server.py b/server.py
index e69de29..b3f4a5d 100644
--- a/server.py
+++ b/server.py
@@ -0,0 +1,28 @@
+import socket 
+
+#local server details
+
+server_address=("127.0.0.1",12345)
+
+client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+
+client_socket.connect(server_address)
+
+# file to send
+file_name = "dicitionary.py"  #json file script
+
+try:
+    # Open file in read me file
+    with open(file_name, "rb") as file:
+        
+        chunk = file.read(1024)
+        while chunk:     #chunk is parts of the file
+            # Send the chunk to the socketserver
+            client_socket.send(chunk)
+            chunk = file.read(1024)
+    print(f"Python script '{file_name}' sent successfully.")
+except FileNotFoundError:
+    print(f"Python script '{file_name}' not found.")
+
+# Close the socket
+client_socket.close()
\ No newline at end of file

commit 01065881570eaf41a225045141394af399be62b8
Merge: 7800b43 cbb00e2
Author: Paul Coleman <colemanp54@icloud.com>
Date:   Fri Sep 29 15:17:44 2023 +0100

    Merge branch 'main' of https://github.com/callmehawa/Client_Server_Network_GroupC

commit 7800b43a683fc34da2a25efa0f0ed07e542f5bdc
Author: Paul Coleman <colemanp54@icloud.com>
Date:   Fri Sep 29 15:17:27 2023 +0100

    Commit Socket Client

diff --git a/client.py b/client.py
index acc5f56..b3f4a5d 100644
--- a/client.py
+++ b/client.py
@@ -1 +1,28 @@
-Test Commit
\ No newline at end of file
+import socket 
+
+#local server details
+
+server_address=("127.0.0.1",12345)
+
+client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+
+client_socket.connect(server_address)
+
+# file to send
+file_name = "dicitionary.py"  #json file script
+
+try:
+    # Open file in read me file
+    with open(file_name, "rb") as file:
+        
+        chunk = file.read(1024)
+        while chunk:     #chunk is parts of the file
+            # Send the chunk to the socketserver
+            client_socket.send(chunk)
+            chunk = file.read(1024)
+    print(f"Python script '{file_name}' sent successfully.")
+except FileNotFoundError:
+    print(f"Python script '{file_name}' not found.")
+
+# Close the socket
+client_socket.close()
\ No newline at end of file

commit cbb00e21d5f5300bb764b102edaa028a0bd1c461
Merge: 08d9045 680ae1e
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Sep 28 21:53:00 2023 +0100

    Merge branch 'main' of https://github.com/callmehawa/Client_Server_Network_GroupC

commit 08d90453680f91c5f0679aabc56c0b8fe3e65f75
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Sep 28 21:52:19 2023 +0100

    corrected the spelling mistake in Server design UML diagram


commit 680ae1e43b0222c593a9613a2e88728162c88dcd
Author: nicolasKappa <nicola.kappa8@gmail.com>
Date:   Thu Sep 28 23:56:29 2023 +0400

    Updated dictionary and deserialization

diff --git a/deserialization.py b/deserialization.py
index 1a03bcc..1d7eda8 100644
--- a/deserialization.py
+++ b/deserialization.py
@@ -4,12 +4,9 @@ The code uses pickle module to deserialize dictionary from file
 # importing pickle module
 import pickle
 
-# Create a dictionary with key-value pairs
-dictionary = {"name": "Pawan", "age": 40, "city": "Preston"}
-
 # deserialize data from file
-with open('dict.json', 'wb') as file:
-    loaded_data = pickle.load(file)
+with open('dict.pickle', 'rb') as file:
+    data = pickle.load(file)
 
 # prints deserialized data
-print(loaded_data)
\ No newline at end of file
+print(data) 
\ No newline at end of file
diff --git a/dicitionary.py b/dicitionary.py
index b75a226..50ed44d 100644
--- a/dicitionary.py
+++ b/dicitionary.py
@@ -8,6 +8,6 @@ import pickle
 # Create a dictionary with key-value pairs
 dictionary = {"name": "Pawan", "age": 40, "city": "Preston"}
 
-# creates new file and convert dictionary to json
-with open('dict.json', 'wb') as file:
+# creates new file to serialize into pickle
+with open('dict.pickle', 'wb') as file:
     pickle.dump(dictionary, file)

commit 7186d8ee66386956a63928ab1fda9b06510862ea
Author: nicolasKappa <nicola.kappa8@gmail.com>
Date:   Thu Sep 28 23:47:05 2023 +0400

    deserialization using pickle in seperate file

diff --git a/deserialization.py b/deserialization.py
new file mode 100644
index 0000000..1a03bcc
--- /dev/null
+++ b/deserialization.py
@@ -0,0 +1,15 @@
+'''
+The code uses pickle module to deserialize dictionary from file
+'''
+# importing pickle module
+import pickle
+
+# Create a dictionary with key-value pairs
+dictionary = {"name": "Pawan", "age": 40, "city": "Preston"}
+
+# deserialize data from file
+with open('dict.json', 'wb') as file:
+    loaded_data = pickle.load(file)
+
+# prints deserialized data
+print(loaded_data)
\ No newline at end of file

commit 8492a9e3f3d750e2cdff0aaa72fdaa99b327a89f
Merge: 8403efe 88f9ee6
Author: nicolasKappa <nicola.kappa8@gmail.com>
Date:   Thu Sep 28 23:37:43 2023 +0400

    Merge branch 'main' of https://github.com/callmehawa/Client_Server_Network_GroupC into main

commit 8403efe28d1cbeed74cf5d84bffacdab0a7318e4
Author: Paul Coleman <colemanp54@icloud.com>
Date:   Thu Sep 28 19:50:30 2023 +0100

    Concerted code into Pickle module

diff --git a/client.py b/client.py
index e69de29..acc5f56 100644
--- a/client.py
+++ b/client.py
@@ -0,0 +1 @@
+Test Commit
\ No newline at end of file
diff --git a/dicitionary.py b/dicitionary.py
index 4f08129..b75a226 100644
--- a/dicitionary.py
+++ b/dicitionary.py
@@ -1,22 +1,13 @@
 '''
-The code creates JSON file for corresponding Key-value paires
-written in dictionary
+The code uses pickle module to serialize dictionary and
+save it to file in binary format
 '''
-# importing Json module
-import json
-
-
-# Create an empty dictionary
-my_dict = {}
+# importing pickle module
+import pickle
 
 # Create a dictionary with key-value pairs
 dictionary = {"name": "Pawan", "age": 40, "city": "Preston"}
 
-# convert dictionary to json
-json_dict = json.dumps(dictionary)
-
-# print dictionary
-print(dictionary)
-
-# Json representation of dictionary
-print(json_dict)
+# creates new file and convert dictionary to json
+with open('dict.json', 'wb') as file:
+    pickle.dump(dictionary, file)
diff --git a/dict.json b/dict.json
new file mode 100644
index 0000000..1da61cf
Binary files /dev/null and b/dict.json differ

commit 2d93e302278f4106b4c5457f7c1ad2eaa80779ff
Author: Olesia Shtern <olesya0789@gmail.com>
Date:   Thu Sep 28 22:19:44 2023 +0300

    added encryption py file, amended typo in dictionary file

diff --git a/.idea/.gitignore b/.idea/.gitignore
new file mode 100644
index 0000000..26d3352
--- /dev/null
+++ b/.idea/.gitignore
@@ -0,0 +1,3 @@
+# Default ignored files
+/shelf/
+/workspace.xml
diff --git a/.idea/Client_Server_Network_GroupC.iml b/.idea/Client_Server_Network_GroupC.iml
new file mode 100644
index 0000000..0efb640
--- /dev/null
+++ b/.idea/Client_Server_Network_GroupC.iml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="PYTHON_MODULE" version="4">
+  <component name="NewModuleRootManager">
+    <content url="file://$MODULE_DIR$">
+      <excludeFolder url="file://$MODULE_DIR$/venv" />
+    </content>
+    <orderEntry type="jdk" jdkName="Python 3.11 (Client_Server_Network_GroupC)" jdkType="Python SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
diff --git a/.idea/inspectionProfiles/Project_Default.xml b/.idea/inspectionProfiles/Project_Default.xml
new file mode 100644
index 0000000..9bd428c
--- /dev/null
+++ b/.idea/inspectionProfiles/Project_Default.xml
@@ -0,0 +1,79 @@
+<component name="InspectionProjectProfileManager">
+  <profile version="1.0">
+    <option name="myName" value="Project Default" />
+    <inspection_tool class="PyPackageRequirementsInspection" enabled="true" level="WARNING" enabled_by_default="true">
+      <option name="ignoredPackages">
+        <value>
+          <list size="66">
+            <item index="0" class="java.lang.String" itemvalue="protobuf" />
+            <item index="1" class="java.lang.String" itemvalue="yarg" />
+            <item index="2" class="java.lang.String" itemvalue="Brlapi" />
+            <item index="3" class="java.lang.String" itemvalue="PyYAML" />
+            <item index="4" class="java.lang.String" itemvalue="ufw" />
+            <item index="5" class="java.lang.String" itemvalue="pycups" />
+            <item index="6" class="java.lang.String" itemvalue="pycairo" />
+            <item index="7" class="java.lang.String" itemvalue="kernelstub" />
+            <item index="8" class="java.lang.String" itemvalue="macaroonbakery" />
+            <item index="9" class="java.lang.String" itemvalue="PyGObject" />
+            <item index="10" class="java.lang.String" itemvalue="systemd-python" />
+            <item index="11" class="java.lang.String" itemvalue="docopt" />
+            <item index="12" class="java.lang.String" itemvalue="PyNaCl" />
+            <item index="13" class="java.lang.String" itemvalue="repoman" />
+            <item index="14" class="java.lang.String" itemvalue="certifi" />
+            <item index="15" class="java.lang.String" itemvalue="oauthlib" />
+            <item index="16" class="java.lang.String" itemvalue="language-selector" />
+            <item index="17" class="java.lang.String" itemvalue="hidpidaemon" />
+            <item index="18" class="java.lang.String" itemvalue="python-xlib" />
+            <item index="19" class="java.lang.String" itemvalue="lazr.restfulclient" />
+            <item index="20" class="java.lang.String" itemvalue="cryptography" />
+            <item index="21" class="java.lang.String" itemvalue="lazr.uri" />
+            <item index="22" class="java.lang.String" itemvalue="python-apt" />
+            <item index="23" class="java.lang.String" itemvalue="SecretStorage" />
+            <item index="24" class="java.lang.String" itemvalue="click" />
+            <item index="25" class="java.lang.String" itemvalue="ubuntu-advantage-tools" />
+            <item index="26" class="java.lang.String" itemvalue="pop-transition" />
+            <item index="27" class="java.lang.String" itemvalue="simplejson" />
+            <item index="28" class="java.lang.String" itemvalue="pyxdg" />
+            <item index="29" class="java.lang.String" itemvalue="idna" />
+            <item index="30" class="java.lang.String" itemvalue="pymacaroons" />
+            <item index="31" class="java.lang.String" itemvalue="distro" />
+            <item index="32" class="java.lang.String" itemvalue="PyJWT" />
+            <item index="33" class="java.lang.String" itemvalue="defer" />
+            <item index="34" class="java.lang.String" itemvalue="netifaces" />
+            <item index="35" class="java.lang.String" itemvalue="more-itertools" />
+            <item index="36" class="java.lang.String" itemvalue="httplib2" />
+            <item index="37" class="java.lang.String" itemvalue="numpy" />
+            <item index="38" class="java.lang.String" itemvalue="requests" />
+            <item index="39" class="java.lang.String" itemvalue="wadllib" />
+            <item index="40" class="java.lang.String" itemvalue="importlib-metadata" />
+            <item index="41" class="java.lang.String" itemvalue="jeepney" />
+            <item index="42" class="java.lang.String" itemvalue="python-debian" />
+            <item index="43" class="java.lang.String" itemvalue="cupshelpers" />
+            <item index="44" class="java.lang.String" itemvalue="screen-resolution-extra" />
+            <item index="45" class="java.lang.String" itemvalue="pydbus" />
+            <item index="46" class="java.lang.String" itemvalue="launchpadlib" />
+            <item index="47" class="java.lang.String" itemvalue="zipp" />
+            <item index="48" class="java.lang.String" itemvalue="sessioninstaller" />
+            <item index="49" class="java.lang.String" itemvalue="louis" />
+            <item index="50" class="java.lang.String" itemvalue="urllib3" />
+            <item index="51" class="java.lang.String" itemvalue="blinker" />
+            <item index="52" class="java.lang.String" itemvalue="ubuntu-drivers-common" />
+            <item index="53" class="java.lang.String" itemvalue="six" />
+            <item index="54" class="java.lang.String" itemvalue="xkit" />
+            <item index="55" class="java.lang.String" itemvalue="pipreqs" />
+            <item index="56" class="java.lang.String" itemvalue="repolib" />
+            <item index="57" class="java.lang.String" itemvalue="chardet" />
+            <item index="58" class="java.lang.String" itemvalue="chrome-gnome-shell" />
+            <item index="59" class="java.lang.String" itemvalue="pyRFC3339" />
+            <item index="60" class="java.lang.String" itemvalue="colorama" />
+            <item index="61" class="java.lang.String" itemvalue="dbus-python" />
+            <item index="62" class="java.lang.String" itemvalue="xdg" />
+            <item index="63" class="java.lang.String" itemvalue="command-not-found" />
+            <item index="64" class="java.lang.String" itemvalue="pytz" />
+            <item index="65" class="java.lang.String" itemvalue="keyring" />
+          </list>
+        </value>
+      </option>
+    </inspection_tool>
+  </profile>
+</component>
\ No newline at end of file
diff --git a/.idea/inspectionProfiles/profiles_settings.xml b/.idea/inspectionProfiles/profiles_settings.xml
new file mode 100644
index 0000000..105ce2d
--- /dev/null
+++ b/.idea/inspectionProfiles/profiles_settings.xml
@@ -0,0 +1,6 @@
+<component name="InspectionProjectProfileManager">
+  <settings>
+    <option name="USE_PROJECT_PROFILE" value="false" />
+    <version value="1.0" />
+  </settings>
+</component>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
index 0000000..b0381f5
--- /dev/null
+++ b/.idea/misc.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.11 (Client_Server_Network_GroupC)" project-jdk-type="Python SDK" />
+</project>
\ No newline at end of file
diff --git a/.idea/modules.xml b/.idea/modules.xml
new file mode 100644
index 0000000..af070ff
--- /dev/null
+++ b/.idea/modules.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/Client_Server_Network_GroupC.iml" filepath="$PROJECT_DIR$/.idea/Client_Server_Network_GroupC.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
index 0000000..35eb1dd
--- /dev/null
+++ b/.idea/vcs.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/__pycache__/cryptography.cpython-311.pyc b/__pycache__/cryptography.cpython-311.pyc
new file mode 100644
index 0000000..5478ea5
Binary files /dev/null and b/__pycache__/cryptography.cpython-311.pyc differ
diff --git a/dicitionary.py b/dictionary.py
similarity index 100%
rename from dicitionary.py
rename to dictionary.py
diff --git a/encryption b/encryption.py
similarity index 97%
rename from encryption
rename to encryption.py
index 55a3178..e2569d4 100644
--- a/encryption
+++ b/encryption.py
@@ -64,4 +64,4 @@ def decrypt(filename, key):
     decrypted_data = f.decrypt(encrypted_data)
     # write the original file
     with open(filename, "wb") as file:
-        file.write(decrypted_data)
\ No newline at end of file
+        file.write(decrypted_data)

commit 88f9ee695590469bbf03a680fb9d7930266ddd8c
Author: Paul Coleman <colemanp54@icloud.com>
Date:   Thu Sep 28 19:50:30 2023 +0100

    Testing GIT Commit Meeting (3)

diff --git a/client.py b/client.py
index e69de29..acc5f56 100644
--- a/client.py
+++ b/client.py
@@ -0,0 +1 @@
+Test Commit
\ No newline at end of file

commit 4c486499f17f1414606e6aa5997e9a1c81298df4
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Sep 28 19:39:35 2023 +0100

    created client and server py for the team to start to program

diff --git a/client.py b/client.py
new file mode 100644
index 0000000..e69de29
diff --git a/server.py b/server.py
new file mode 100644
index 0000000..e69de29

commit cf6703a9f4e5a292cf2e5faf8e736b8d85691817
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Sep 28 19:05:00 2023 +0100

    Olesia's code for encrypting the file. comitting to Github as she is unable to do.

diff --git a/encryption b/encryption
index b870c10..55a3178 100644
--- a/encryption
+++ b/encryption
@@ -1,43 +1,67 @@
-import json
 from cryptography.fernet import Fernet
 
-# Create a dictionary with key-value pairs
-dictionary = {"name": "Pawan", "age": 40, "city": "Preston"}
 
-# Convert dictionary to JSON
-json_dict = json.dumps(dictionary)
+def write_key():
+    """
+    Generating a key and saving it into a file
+    """
+    key = Fernet.generate_key()
+    with open("key.key", "wb") as key_file:
+        key_file.write(key)
 
-# Generate a secret key for encryption (keep this secret)
-secret_key = Fernet.generate_key()
 
-# Initialize the Fernet cipher with the secret key
-cipher_suite = Fernet(secret_key)
+def load_key():
+    """
+    Loading the key from the current directory named `key.key`
+    """
+    return open("key.key", "rb").read()
 
-# Encrypt the JSON data
-encrypted_data = cipher_suite.encrypt(json_dict.encode())
 
-# Save the encrypted data to a file
-with open('encrypted_data.json', 'wb') as file:
-    file.write(encrypted_data)
+# generating and writing a new key
+write_key()
 
-# Print the secret key (keep this secret for decryption)
-#print("Secret Key:", secret_key)
+# loading the previously generated key
+key = load_key()
 
-# Read the encrypted data from the file
-with open('encrypted_data.json', 'rb') as file:
-    encrypted_data = file.read()
+message = "some secret message".encode()
 
-# Add the key you generated to start decrypting the file
-secret_key = Fernet(secret_key)
+# initializing the Fernet class
+f = Fernet(key)
 
-# Initialize the Fernet cipher with the secret key
-cipher_suite = Fernet(secret_key)
+# encrypting the message
+encrypted = f.encrypt(message)
 
-# Decrypt the data
-decrypted_data = cipher_suite.decrypt(encrypted_data)
+# printing how it looks
+print(encrypted)
 
-# Convert the JSON data back to a dictionary
-dictionary = json.loads(decrypted_data.decode())
 
-# Print the decrypted dictionary
-print(dictionary)
+def encrypt(filename, key):
+    """
+    Given a filename (str) and key (bytes), it encrypts the file and write it
+    """
+    f = Fernet(key)
+    with open(filename, "rb") as file:
+        # read all file data
+        file_data = file.read()
+
+    # encrypt data
+    encrypted_data = f.encrypt(file_data)
+
+    # write the encrypted file
+    with open(filename, "wb") as file:
+        file.write(encrypted_data)
+
+
+def decrypt(filename, key):
+    """
+    Given a filename (str) and key (bytes), it decrypts the file and write it
+    """
+    f = Fernet(key)
+    with open(filename, "rb") as file:
+        # read the encrypted data
+        encrypted_data = file.read()
+    # decrypt data
+    decrypted_data = f.decrypt(encrypted_data)
+    # write the original file
+    with open(filename, "wb") as file:
+        file.write(decrypted_data)
\ No newline at end of file

commit 3cb7ea2023acfd84ccdac61de21f20acdaee3f61
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Sep 28 16:33:00 2023 +0100

    added encryption file with encryption and decription function using fernet

diff --git a/encryption b/encryption
index 3d46884..b870c10 100644
--- a/encryption
+++ b/encryption
@@ -21,8 +21,7 @@ with open('encrypted_data.json', 'wb') as file:
     file.write(encrypted_data)
 
 # Print the secret key (keep this secret for decryption)
-print("Secret Key:", secret_key)
-
+#print("Secret Key:", secret_key)
 
 # Read the encrypted data from the file
 with open('encrypted_data.json', 'rb') as file:

commit cd1f0de35979dab46a917186f71570ec7f7e970f
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Sep 28 16:26:51 2023 +0100

    added encryption file to start encryption and decryption function

diff --git a/encryption b/encryption
new file mode 100644
index 0000000..3d46884
--- /dev/null
+++ b/encryption
@@ -0,0 +1,44 @@
+import json
+from cryptography.fernet import Fernet
+
+# Create a dictionary with key-value pairs
+dictionary = {"name": "Pawan", "age": 40, "city": "Preston"}
+
+# Convert dictionary to JSON
+json_dict = json.dumps(dictionary)
+
+# Generate a secret key for encryption (keep this secret)
+secret_key = Fernet.generate_key()
+
+# Initialize the Fernet cipher with the secret key
+cipher_suite = Fernet(secret_key)
+
+# Encrypt the JSON data
+encrypted_data = cipher_suite.encrypt(json_dict.encode())
+
+# Save the encrypted data to a file
+with open('encrypted_data.json', 'wb') as file:
+    file.write(encrypted_data)
+
+# Print the secret key (keep this secret for decryption)
+print("Secret Key:", secret_key)
+
+
+# Read the encrypted data from the file
+with open('encrypted_data.json', 'rb') as file:
+    encrypted_data = file.read()
+
+# Add the key you generated to start decrypting the file
+secret_key = Fernet(secret_key)
+
+# Initialize the Fernet cipher with the secret key
+cipher_suite = Fernet(secret_key)
+
+# Decrypt the data
+decrypted_data = cipher_suite.decrypt(encrypted_data)
+
+# Convert the JSON data back to a dictionary
+dictionary = json.loads(decrypted_data.decode())
+
+# Print the decrypted dictionary
+print(dictionary)

commit 83dcdc6f86317a52ee60598cce9a9f91d3cce0c5
Merge: 1db73f4 468513b
Author: ThatalP <142354418+callmehawa@users.noreply.github.com>
Date:   Thu Sep 28 15:41:56 2023 +0100

    Merge pull request #1 from callmehawa/readme
    
    Readme

commit 468513b6a9c824cd9c8e6dd8e63e592373f17a4f
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Sep 28 15:39:43 2023 +0100

    udpated the readme file with the additional details of the project

diff --git a/README.md b/README.md
index d384f1e..e59a7a9 100644
--- a/README.md
+++ b/README.md
@@ -17,6 +17,5 @@ Pull request accepted
 
 ## License
 
-No Licence
-
+No Licence required
 

commit fd8187da0908ef72343eaa5b4cecceb8910ee1ff
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Sep 28 15:35:28 2023 +0100

    updated the readme file with the additional details of the project

diff --git a/README.md b/README.md
index f79d7c4..d384f1e 100644
--- a/README.md
+++ b/README.md
@@ -1,22 +1,22 @@
-# Title
+# Group Project to create a simple client server network
 
-This is an example file with default selections.
+This is a Project to create a simple Client Server network. Create a dictionary, popluate it, serialise and encrypt it and send it to the server. 
+The server will receive the file, decrypt, deserialise it and print the file
 
 ## Install
 
-```
-```
+cyrptography
 
 ## Usage
 
-```
-```
+Demonstration of simple client server network and how a string can be serialised, encrypted and sent. 
 
 ## Contributing
-
-Pull request accepted.
+Group C end of module assignment
+Pull request accepted
 
 ## License
 
 No Licence
 
+

commit e088761011cc8984598e5959ef6fe645eee63ee0
Merge: c756387 1db73f4
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Sep 28 15:13:06 2023 +0100

    Merge branch 'main' of https://github.com/callmehawa/Client_Server_Network_GroupC

commit c756387e830f2580fcd86a8f40fed387d638d0bf
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Thu Sep 28 11:01:14 2023 +0100

    Amended client and server design to include key management class

diff --git a/Group C - Client Server Network Report.docx b/Group C - Client Server Network Report.docx
index 81e78ea..664a02f 100644
--- a/Group C - Client Server Network Report.docx	
+++ b/Group C - Client Server Network Report.docx	
@@ -160,6 +160,7 @@ Error handling will check if the file has been written
 
 
 Solution Design (Server) 
+   
 
 Description of activities
 1

commit 1db73f41132b3dd4ecd8fe58ed0560f288f5760f
Author: nicolasKappa <nicola.kappa8@gmail.com>
Date:   Thu Sep 28 03:25:05 2023 +0400

    json_representation_of_dict

diff --git a/dicitionary.py b/dicitionary.py
index 7bb4884..4f08129 100644
--- a/dicitionary.py
+++ b/dicitionary.py
@@ -1,8 +1,22 @@
+'''
+The code creates JSON file for corresponding Key-value paires
+written in dictionary
+'''
+# importing Json module
+import json
+
+
 # Create an empty dictionary
 my_dict = {}
 
 # Create a dictionary with key-value pairs
 dictionary = {"name": "Pawan", "age": 40, "city": "Preston"}
 
-#print dictionary
-print(dictionary)
\ No newline at end of file
+# convert dictionary to json
+json_dict = json.dumps(dictionary)
+
+# print dictionary
+print(dictionary)
+
+# Json representation of dictionary
+print(json_dict)

commit 468b2526908777609b30c43c01a167f30be4dd76
Author: callmehawa <thatal.pawan@gmail.com>
Date:   Wed Sep 27 22:59:20 2023 +0100

    added a new code to create a simple dicitionary
    This dicitionary code can be used by the team to familiarise ourselves with pull the code, amending and commiting it

diff --git a/dicitionary.py b/dicitionary.py
new file mode 100644
index 0000000..7bb4884
--- /dev/null
+++ b/dicitionary.py
@@ -0,0 +1,8 @@
+# Create an empty dictionary
+my_dict = {}
+
+# Create a dictionary with key-value pairs
+dictionary = {"name": "Pawan", "age": 40, "city": "Preston"}
+
+#print dictionary
+print(dictionary)
\ No newline at end of file

commit 6ab0a2ce0b55febdf729873f60d0487e91aba66c
Author: ThatalP <142354418+callmehawa@users.noreply.github.com>
Date:   Tue Sep 26 00:55:51 2023 +0100

    Add files via upload
    
    Solution design for client added using UML
    Design decision updated following a meeting with Team.
    decision was taken to use JSON format for serialisation and fernet for encryption.

diff --git a/Group C - Client Server Network Report.docx b/Group C - Client Server Network Report.docx
index 4df89b6..0190c38 100644
--- a/Group C - Client Server Network Report.docx	
+++ b/Group C - Client Server Network Report.docx	
@@ -80,22 +80,40 @@ dd/mm/20x
 TABLE OF CONTENTS
          
 	Page
-Chapter 1. Introduction	2
-Chapter 2. Solution Design	3
-2.1	Solution overview	3
-2.2	Technical Flow	4
-2.3	Design Decision	4
-Chapter 3. Testing	5
-3.1	Serialization Unit Testing	5
-3.2	Encryption Unit Testing	5
-3.3	Network Unit Testing	5
-3.4	File Transfer Unit Testing	5
-3.5	Decryption Unit Testing	5
-3.6	De-Serialization Unit Testing	5
-3.7	Integration Testing	5
-Chapter 4. Conclusion	5
-REFERENCES	6
-APPENDICES	6
+Chapter 1. Introduction	3
+Chapter 2. Solution Design	4
+2.1	Solution overview	4
+2.2	Technical Flow	5
+2.3	Solution Design (Client)	5
+2.4	Solution Design (Server) 	6
+2.5	Design Decision	6
+Chapter 3. Testing	6
+3.1	Serialization Unit Testing	7
+3.2	Encryption Unit Testing	7
+3.3	Network Unit Testing	7
+3.4	File Transfer Unit Testing	7
+3.5	Decryption Unit Testing	7
+3.6	De-Serialization Unit Testing	7
+3.7	Integration Testing	7
+Chapter 4. Conclusion	7
+REFERENCES	8
+APPENDICES	8
+	
+	
+		
+		
+		
+	
+		
+		
+		
+		
+		
+		
+		
+	
+	
+	
 
                     
 {To update the LIST OF FIGURES, right click on the entries, chose "Update Field", choose "Update entire table" and click on OK}
@@ -115,38 +133,54 @@ Solution overview
 Technical Flow
 
                            Figure 2. Technical Flow
+Solution Design (Client)
 
+                                       
+                                       
 
 Description of activities
 1
-User to input a Dictionary or Text File (How would user input, will it be a front end?
+User to input as Dictionary. 
+
 2
-File is serialised using Pickle module into a Binary, JSON or XML format
+File is serialised using Pickle module JSON
 3
-File is encrypted using....  
-How you encrypt a file or dictionary will be different
+File is encrypted using Cryptography modules Fernet Object 
 4
-Key pair generation (store the public / private key pair)
+Token is generated to encrypt the file 
 5
-Connection is established from client to the server
-6
-Encrypted file is sent to server (using https an API call)
-7
-Server receives the file and decrypts
-8
-File is de-serialised and store. Where?
-9
-Received file is printed or written to a file
+Error handling will check if the file has been written
+
+
+
+
+
 
+
+
+
+Solution Design (Server) 
+
+Description of activities
+1
+Server to listen to incoming calls
+2
+Server receives the file and decrypts
+3
+File is de-serialised
+4
+Received file is printed.
 Design Decision
 
 Design decisions
 1
-Decision to use text file because....
+Agreed to use json formatting for serialisation since json is compact, concise and easier to read.
+
+
 2
-File serialised into JSON because...
-3
-File encoding decision.. 
+Fernet Object will be used for encrypting the file due to it's simplicity and easy of use. Fernet is a symmetric encryption algorithm, meaning it uses the same key for both encryption and decryption  
+
+
 Testing
 {This final chapter serves as a summary of the project from a holistic perspective.  It includes a critical review of the achievements and limitations of the project, from both an academic and business perspective.  It includes suggestions for potential research in the future}
 Serialization Unit Testing

commit 445b9746099fcb360bffd552613afb5b304a561e
Author: ThatalP <142354418+callmehawa@users.noreply.github.com>
Date:   Mon Sep 25 21:13:08 2023 +0100

    Create requirement.txt
    
    Created requirement.txt file for the Client Network Project.

diff --git a/requirement.txt b/requirement.txt
new file mode 100644
index 0000000..68549c6
--- /dev/null
+++ b/requirement.txt
@@ -0,0 +1 @@
+# Only list libraries that are installed part of the Project, no need for a import statement.

commit 218ffac401a8330dfa53afb474f26dbbdfca1d8a
Author: ThatalP <142354418+callmehawa@users.noreply.github.com>
Date:   Mon Sep 25 21:10:01 2023 +0100

    Updated README.md
    
    Updated the readme file with an example template based on Lecturer's feedback from the previous assignment.

diff --git a/README.md b/README.md
index cfdc5a8..f79d7c4 100644
--- a/README.md
+++ b/README.md
@@ -1 +1,22 @@
-# Client_Server_Network_GroupC Project report that includes draft Architecture Diagram and Technical flow 
+# Title
+
+This is an example file with default selections.
+
+## Install
+
+```
+```
+
+## Usage
+
+```
+```
+
+## Contributing
+
+Pull request accepted.
+
+## License
+
+No Licence
+

commit cb2b9abe1734618b0173ccac002c68c6fe09e40c
Author: callmehawa <142354418+callmehawa@users.noreply.github.com>
Date:   Mon Sep 25 09:09:33 2023 +0100

    Create README.md

diff --git a/README.md b/README.md
new file mode 100644
index 0000000..cfdc5a8
--- /dev/null
+++ b/README.md
@@ -0,0 +1 @@
+# Client_Server_Network_GroupC Project report that includes draft Architecture Diagram and Technical flow 

commit 578c3973bc908a0c451c63023abb01d34a584cae
Author: callmehawa <142354418+callmehawa@users.noreply.github.com>
Date:   Fri Sep 22 22:39:25 2023 +0100

    Add files via upload
    
    The first draft of the Group C Project - Client Server Network. This version includes a Solution overview and Technical flow. To be discussed with the rest of the team.

diff --git a/Group C - Client Server Network Report.docx b/Group C - Client Server Network Report.docx
new file mode 100644
index 0000000..4df89b6
--- /dev/null
+++ b/Group C - Client Server Network Report.docx	
@@ -0,0 +1,183 @@
+
+
+REPORT TITLE
+
+
+
+By
+
+Group C
+
+
+
+
+
+
+
+
+Submitted to
+	
+The University of Liverpool
+
+
+
+MASTER-OF-SCIENCE-TITLE
+
+
+Module-Name
+
+
+Word Count: XXX
+
+
+{The Word Count does take into consideration all sections between the Introduction and Conclusions included. Please, do not include the amount of words used for references, title page, ToC, LoT, LoF.}
+                                       
+
+dd/mm/20xx
+
+
+
+
+
+REPORT TITLE
+
+
+
+
+
+
+
+
+
+
+
+
+Submitted to
+	
+The University of Liverpool
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Word Count: XXX
+
+                                       
+
+dd/mm/20x
+
+
+TABLE OF CONTENTS
+         
+	Page
+Chapter 1. Introduction	2
+Chapter 2. Solution Design	3
+2.1	Solution overview	3
+2.2	Technical Flow	4
+2.3	Design Decision	4
+Chapter 3. Testing	5
+3.1	Serialization Unit Testing	5
+3.2	Encryption Unit Testing	5
+3.3	Network Unit Testing	5
+3.4	File Transfer Unit Testing	5
+3.5	Decryption Unit Testing	5
+3.6	De-Serialization Unit Testing	5
+3.7	Integration Testing	5
+Chapter 4. Conclusion	5
+REFERENCES	6
+APPENDICES	6
+
+                    
+{To update the LIST OF FIGURES, right click on the entries, chose "Update Field", choose "Update entire table" and click on OK}
+
+
+Introduction
+{This chapter introduces the Report, its aims and objectives, the IT artefact to be investigated, the problem, the question(s), approach and potential outcome.}
+
+
+Solution Design
+{This chapter represents the main section of your report. It develops argument point by point, including the reasons that support the argument you declared in your introduction.)
+                                       
+Solution overview
+                                       
+                                       
+                          Figure 1. Solution overview
+Technical Flow
+
+                           Figure 2. Technical Flow
+
+
+Description of activities
+1
+User to input a Dictionary or Text File (How would user input, will it be a front end?
+2
+File is serialised using Pickle module into a Binary, JSON or XML format
+3
+File is encrypted using....  
+How you encrypt a file or dictionary will be different
+4
+Key pair generation (store the public / private key pair)
+5
+Connection is established from client to the server
+6
+Encrypted file is sent to server (using https an API call)
+7
+Server receives the file and decrypts
+8
+File is de-serialised and store. Where?
+9
+Received file is printed or written to a file
+
+Design Decision
+
+Design decisions
+1
+Decision to use text file because....
+2
+File serialised into JSON because...
+3
+File encoding decision.. 
+Testing
+{This final chapter serves as a summary of the project from a holistic perspective.  It includes a critical review of the achievements and limitations of the project, from both an academic and business perspective.  It includes suggestions for potential research in the future}
+Serialization Unit Testing
+Encryption Unit Testing
+Network Unit Testing
+File Transfer Unit Testing
+Decryption Unit Testing
+De-Serialization Unit Testing
+Integration Testing
+
+Conclusion
+REFERENCES
+{The purpose of a citation is to lead the reader to the correct reference entry. If it is a quote, the in-text citation includes the page of the quote so that the reader goes to the reference entry to access the source and then the page. Only sources actually cited are included in a reference section. You may have had other sources you read but ended up not citing. They are not included in the References listing. 
+This section includes all references cited, using the Harvard-style referencing format as described within the University Library portal.} 
+
+
+
+
+APPENDICES 
+
+Group Artifacts
+1
+GitHub Repository
+2
+Client Server Network Project report
+3
+Requirement.txt
+4
+Readme.md
+5
+Log of Github code review
+6
+Log of Github push comments
+
